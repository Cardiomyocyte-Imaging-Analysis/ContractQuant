function [TrackingDistance_um,PixelDistance,ContractionFrequency,median_max_FrShort,median_min_Length,median_Contract_20Vel,median_Contract_50Vel,median_Contract_80Vel,median_Relax_80Vel,median_Relax_50Vel,median_Relax_20Vel,...
    median_Contract_20VelNorm,median_Contract_50VelNorm,median_Contract_80VelNorm,median_Relax_80VelNorm,median_Relax_50VelNorm,median_Relax_20VelNorm,median_max_ContractAccel,...
    median_Relaxation_Acceleration_time,median_Contraction_time,median_Contraction_Deceleration_time,median_Relaxation_time,median_event_time,median_max_Contract_Vel,median_max_Relax_Vel,...
    Velocity_Asymmetry_Index,std_inst_fre,std_max_FrShort,std_min_Length,std_Contract_20Vel,std_Contract_50Vel,std_Contract_80Vel,std_Relax_80Vel,std_Relax_50Vel,std_Relax_20Vel,std_max_ContractAccel,...
    std_Relaxation_Acceleration_time,std_Contraction_time,std_Contraction_Deceleration_time,std_Relaxation_time,std_event_time,std_max_Contract_Vel,std_max_Relax_Vel] = ContractQuantM2D(Path,File,dirOut,Tif,offsetMargin)

% Purpose: 
% Semiautomatic tracking of micron-scale 2D cardiac muscle bundle (2DMB) 
% contractions using cross-correlation of two defined ROIs 
% - Original Generated by Yu-Wei Wu (wuyuwei.riken@gmail.com) 2019.3.28
% - Modifications by Helms Lab 
% - Release version 1 2021.9.14
% 
% Reference: Tsan et al., Nature Communications 2021
%
% License: MIT (see GitHub license file)
%
% Inputs:
% The ContractQuant code is expected to be run via the ContractQuantBatch
% script. For one-at-a-time processing with manual ROI selection, use
% ContractQuantManual instead. For disorganized (nonpatterned) iPSC-CMs,
% use ContractQuantSimple instead.
%
% Outputs:
% All the peri-event traces (PETs) of Length, Speed, Accelaration, Symmetic Index 
% Results including: Event onset times, Instantaneous Frequency,
% Mean and Std of Instantaneous Frequency, peak displacement, speed,
% accelaration, assymetric index, half-duration
%
% Files saved:
% 1. Reference image of ROIs.
% 2. Plots of all normalized full traces
% 3. Plots of mean +- sem of PETs
% 4. [filename].xls
%
%

    tic
    clc
    warning('off', 'all')
    close all 

    cd(Path)
    
   
    
    
    
    
    % ***************PARAMETER SETTING************

    PixelDistance = 0.16; %(um/pixel)
    SamplingInterval = 0.02; %(sec)
    %Note SamplingInterval and PixelDistance will be over-ridden by metadata if bio-formats
    %metadata available from nd2 file.
    
    % Set the x and y coordinates for 2 tracking points 
    defaultXs=[580,1460]'; % [x position of point 1, x position of point 2]
    defaultYs=[224,224]'; % [y position of point 1, y position of point 2]
    
    % Set the ROI size
    ROIsize=100;
    
    
    % ********************************************

    % Open image files from tiff
    
    if Tif == 1
        %%[FileTif,path,FilterIndex] = uigetfile('*.tif', 'Select image file');
        name = File;
        fprintf('Now analyzing %s\n', name);
        InfoImage=imfinfo(File); % get image information
        mImage=InfoImage(1).Width;% get image size: x,y,and z or t
        nImage=InfoImage(1).Height;
        NumberImages=length(InfoImage); 
        FinalImage=zeros(nImage,mImage,NumberImages,'uint8');
        TifLink = Tiff(File, 'r');
        for i=1:NumberImages
            TifLink.setDirectory(i);
            FinalImage(:,:,i)=TifLink.read();
        end
        TifLink.close();
        
    else
        
        % open nd2 file using Bio-Formats toolbox 
        
        %%[FileTif,path,FilterIndex] = uigetfile('*.nd2', 'Select image file');
        name = File;
        fullpath = sprintf('%s/%s',Path,name);
        fprintf('Now analyzing %s\n', name);
        data = bfopen(fullpath);
        for t =1 : length(data{1,1})  
            FinalImage(:,:,t)=data{1,1}{t,1};
        end
        Metadata = char(data{1,2});
        index = strfind(Metadata,'dAvgPeriodDiff='); %index for average time sampling interval
        index2 = strfind(Metadata,'Global dCalibration='); %index for global calibration
        SamplingInterval = double(str2num(Metadata(index+15:index+23)))/1000;%(sec) 
        PixelDistance = double(str2num(Metadata(index2+20:index2+25))); %micron/pixel
        clear data
        
    end
    Z = FinalImage;
    
        SAMPLE_FREQ = round(1/SamplingInterval); %(Hz)
        TRACE_WIN = 0.5 * SAMPLE_FREQ;
        fprintf('Sampling Interval is %.3f (ms)\n',SamplingInterval*1000);
        fprintf('Sampling Frequency is %d (Hz)\n',SAMPLE_FREQ);
        fprintf('Trace Duration is %d (sec)\n',TRACE_WIN*2.5);

    % Auto windows the image by scaling the image to pixel intensities of mean +/- 2* standard deviation, then scales to 0 to 66000 
    % This avoids errors from increased background and windows to uint16
    Z=im2double(Z); %converts to double format, then reverts back to unit16 after scaling
    ImgMean = mean(Z(:));
    ImgStd = std(Z(:));
    
    for f=1:size(Z,3)
        Z(:,:,f)=imadjust(Z(:,:,f),[(ImgMean-2*ImgStd) (ImgMean+2*ImgStd)]);
    end
    Z=uint16(Z*65535); %conversion back to uint16 format from double
    FirstFrame=Z(:,:,1);
    twimshow1({FirstFrame},{[0 65535]}); % display invert and original image (first frame)
    set(gcf, 'position', [10 500 1000 300]);
    
    % lable number 
    xlbl = defaultXs +10; ylbl = defaultYs -10;
    % create number labels
    lbl = strtrim(cellstr(num2str((1:numel(defaultXs))')));
    text(xlbl(:), ylbl(:), lbl(:),'color','y',...
        'HorizontalAlignment','center','VerticalAlignment','middle');
    text(defaultXs(:), defaultYs(:), 'o','color','r',...
        'HorizontalAlignment','center','VerticalAlignment','middle');

    % Save referernce image as matlab .fig
    filename = sprintf('%s_ROI_reference',name);%Prompt user
    fprintf('Reference image saved as %s\n', filename)
    hfigs = get(0, 'children');
    figure(size(hfigs(:),1));
    cd(dirOut)
    saveas(size(hfigs(:),1), [filename '.tif']);
    cd(Path)
    
% Create ROI images as the dimention specified below

    for i = 1:size(defaultXs,1)
        if i == 1
            ROI{i} = Z(defaultYs(i)-ROIsize:defaultYs(i)+ROIsize,defaultXs(i)-ROIsize:defaultXs(i)+ROIsize,:);
        else
            ROI{i} = Z(defaultYs(i)-ROIsize:defaultYs(i)+ROIsize,defaultXs(i)-ROIsize:defaultXs(i)+ROIsize,:);
        end
    end
    
    % Use local feature to do crosscorrelation
    
    fprintf('Analyzing displacement\n');
    for i = 1:size(defaultXs,1)
        [ZZ,X,Y] = CorrectOffset_YT(ROI{i},60);
        LocationX{i}=movmean(X,3);
        LocationY{i}=movmean(Y,3);
        ROI_Reg{i} = ZZ;
        twimshow1({ZZ,ROI{i}},{[],[]}); % plot the registered(ZZ) and the original(ROI{i}) images
        set(gcf, 'position', [50+200*(i-1) 300 200 200]);
        twimshow1({std(single(ZZ),0,3),std(single(ROI{i}),0,3)},{[],[]}); % plot the registered(ZZ) and the original(ROI{i}) images
        colormap jet;
        set(gcf, 'position', [50+200*(i-1) 100 200 200]);
    end
    S = size(ROI{1});

% Calculation of Length (distance between ROIs for each frame)

    Length_ini = norm([defaultXs(1) defaultYs(1)] - [defaultXs(2) defaultYs(2)]); % Initial length defined by ROI clicks
    for j = 1 : S(3)-1
        XX(j) = LocationX{1}(j+1) - LocationX{2}(j+1) ;
        YY(j) = LocationY{1}(j+1) - LocationY{2}(j+1) ;
    end  
        XXX = XX - min(XX);
        YYY = YY - min(YY);    
    for j = 1 : S(3)-1
        Length(j) = Length_ini + sqrt(XXX(j)^2+YYY(j)^2);
    end 
    maxLength = round(prctile(Length,95));
    norLength = Length/maxLength; %Normalize the length to the top 5th percentile of length (this removes outliers as compared to using max length)
    delta_norLength = (1-norLength) *100; % Calculate the delta Length (%). This is equivalent to fractional shortening.
    nor_delta_norLength = delta_norLength/max(delta_norLength(:)); % Normalized the delta Length
    
% Calculation of Contraction Velocity (um/second) for all frames (absolute
% value, independently for each ROI - this enables subsequent calculation of asymetric index)

    for i = 1:size(defaultXs,1)
        for j = 1 : S(3)-1
        Speed{i}(j) = norm([LocationX{i}(j) LocationY{i}(j)] - [LocationX{i}(j+1) LocationY{i}(j+1)])/SamplingInterval * PixelDistance;
        end 
        % Normalized velocity for each side
        norSpeed{i}=Speed{i}/max(Speed{i}(:));
    end

% Summed velocity by adding velocity of two sides for all frames (absolute
% velocity)
    SpeedAll = Speed{1} + Speed{2};
    norSpeedAll = SpeedAll/max(SpeedAll(:));
    Accelaration = zeros([2 length(SpeedAll)],'double');
    Accelaration(1,2:end) = diff(Speed{1});
    Accelaration(2,2:end) = diff(Speed{2});
    AccelarationAll =  Accelaration(1,:)+Accelaration(2,:);
    norAccelarationAll = AccelarationAll/max(AccelarationAll(:));
    % 
    
% Calculate the Asymetric Index as (Speed left - Speed right)/(Speed left + Speed right + 1)

    asymmetricIndex = (Speed{1}(:)-Speed{2}(:))./(Speed{1}(:)+Speed{2}(:)+1);
    nor_asymmetricIndex = asymmetricIndex./max(asymmetricIndex(:));
    nor_asymmetricIndex(norSpeedAll <=0.05)=0;
    asymmetricIndex(norSpeedAll <=0.05)=0;
    
    FullTracesAl(1,:) = delta_norLength;
    FullTracesAl(2,:) = SpeedAll;
    FullTracesAl(3,:) = AccelarationAll;
    FullTracesAl(4,:) = asymmetricIndex;
 
%  Calculated the Asymetric Index at Time of Maximum Velocity at any point
%  during the acquisition
    Max_Velocity = max(SpeedAll, [], 2);
    Max_Vel_Index = min(find(SpeedAll(:) == Max_Velocity));
    Velocity_Asymmetry_Index = asymmetricIndex(Max_Vel_Index);
    
    % plot normalized full traces
    
    figure,
    hold on
    plot(movmean(norSpeedAll,3),'color','r');
    plot(movmean(nor_delta_norLength,3),'color','k');
    %plot(movmean(norAccelarationAll,3),'color','b');
    %Splot(movmean(nor_asymmetricIndex,3),'color','g');
    set(gcf, 'position', [450 100 500 300]);
    
     % Save normalized traces
    filename = sprintf('%s_NorFullTraces',name);%Prompt user
    fprintf('Normalized Full Traces saved as %s\n', filename)
    hfigs = get(0, 'children');
    figure(size(hfigs(:),1));
    cd(dirOut)
    saveas(size(hfigs(:),1), [filename '.fig']);
    cd(Path)
    
% Preliminary calculation of contraction durations to set peri-event
% windows correctly
   
    % First, create a binary variable for whether each frame is below
    % threshold
        
    thresh_triggering_signal = nor_delta_norLength;%delta_norLength;
    onset_thresh_low = 0.5; % (full event = 0-1)
    baseline_thresh = 0.3;

    if nargin == 0   
       margin = 5;
    else
        margin = 5 + offsetMargin;
    end
    aboveThresh = [];
        
    for i = 1:length(delta_norLength)
        if thresh_triggering_signal(i)>baseline_thresh
            aboveThresh(i)=1;
        else aboveThresh(i)=0;
        end
    end
    
    %Second, create a variable that counts consecutive points above
    %displacement threshold and resets when displacement falls below threshold
    
    consecThresh = aboveThresh;
    consecThresh(1) = 0; %the next logic starts at frame 2, so the first index value is set to 0
    
    for i = 2:length(delta_norLength)
        if aboveThresh(i)==0
            consecThresh(i)=0;
        else consecThresh(i) = consecThresh(i-1) + 1;%if the frame is above displacement threshold and preceding frame is above threshold, they are summed
        end
    end
    
    %Find the maximum number of consecutive frames above threshold in the
    %movie (i.e. measures the longest contraction time in frames, only counting above the threshold contraction)
    
    prelimDuration = max(consecThresh); 
    
    %Third, find the contraction onsets assuming that a real contraction
    %will have at least 20 consecutive frames above baseline
        
     prelimOnsets = [];
     
     for i = 2:length(delta_norLength)-25
         if aboveThresh(i-1)==0
             %if consecThresh(i+9)==10 %if 10 consecutive frames above baseline following a frame with displacement<threshold, indicates a contraction
             if consecThresh(i+7)==8 %if 8 consecutive frames above baseline following a frame with displacement<threshold, indicates a contraction
                 prelimOnsets = [prelimOnsets,i];
             end
         end
     end
     
     %Fourth, filter the prelim onsets for only those not too close to beginning and
     %end of video, which would create issues with subsequent measurements.
     
     filteredOnsets = [];
     
     %filter for onsets prior to beginning of video
     if prelimOnsets(1) > margin*2+1 
         filteredOnsets = [filteredOnsets,prelimOnsets(1)];
     end
     
     %filter for onsets too close to end of video
     for i = 2:length(prelimOnsets)
        if prelimOnsets(i) + prelimDuration + margin*2 < length(delta_norLength) 
            filteredOnsets = [filteredOnsets,prelimOnsets(i)];
        end
     end
     
     %Fifth, shift filtered onsets earlier by (margin) frames each for the final
     %onsets and add (margin*2) frames total to the prelimDuration to get the
     %finalDuration
     
     onsets=[];
     for i=1:length(filteredOnsets)
        onsets=[onsets,filteredOnsets(i)-margin];
     end
     
     contractDur = prelimDuration + margin*2;
     
     %Fifth, find local maxima by working forward from each of the final
     %onsets
     
     local_maxima = [];
     
     for i=1:length(onsets)
         for j = onsets(i) + contractDur : -1 : onsets(i)  
            if nor_delta_norLength(j)>= nor_delta_norLength(onsets(i):(onsets(i) + contractDur))
                local_maxima(i) = j;
            end
         end
     end
     
     num_maxima = length(local_maxima);
      
% instantanous frequency and stats
% only calculate instantaneous frequency if more than 1 event
    if num_maxima >1
        
    for i = 1:length(local_maxima)-1
        inst_fre(i) = 1/(local_maxima(i+1) - local_maxima(i)) * SAMPLE_FREQ;
    end
    ContractionFrequency = mean(inst_fre,2);
    std_inst_fre = std(inst_fre,[],2);
    end
    
    if num_maxima <2
        inst_fre=[];
        ContractionFrequency=0;
        std_inst_fre=0;
    end
    
  % Get peri-event traces (PETs)

        PET_Win = contractDur;
        PET_Win_Con = round(median(local_maxima - onsets));
        PET_Win_Rel = PET_Win - PET_Win_Con;
        event_ts = onsets;
        num_events = num_maxima;
        
        FrShort_PETs = nan(num_events, PET_Win);
        Speed_PETs = nan(num_events, PET_Win);
        Accel_PETs = nan(num_events, PET_Win);
        Symme_PETs = nan(num_events, PET_Win);
        
        ContractVel_PETs = nan(num_events, PET_Win_Con);
        ContractAccel_PETs = nan(num_events, PET_Win_Con);
        RelaxVel_PETs = nan(num_events, PET_Win_Rel);
        
        for j = 1:num_events
            FrShort_PETs(j, :) = delta_norLength(onsets(j) : onsets(j) + PET_Win -1);
        end
        for j = 1:num_events
            Speed_PETs(j, :) = SpeedAll(onsets(j) : onsets(j) + PET_Win -1);
        end     
        for j = 1:num_events
            Accel_PETs(j, :) = AccelarationAll(onsets(j) : onsets(j) + PET_Win -1);
        end
        for j = 1:num_events
            Symme_PETs(j, :) = asymmetricIndex(onsets(j) : onsets(j) + PET_Win -1);
        end
        
        %contraction only
        for j = 1:num_events
            ContractFrShort_PETs(j, :) = delta_norLength(onsets(j) : onsets(j) + PET_Win_Con -1);
        end        
        for j = 1:num_events
            ContractVel_PETs(j, :) = SpeedAll(onsets(j) : onsets(j) + PET_Win_Con -1);
        end  
        for j = 1:num_events
            ContractAccel_PETs(j, :) = AccelarationAll(onsets(j) : onsets(j) + PET_Win_Con -1);
        end  
        
        Max_ContractVel = max(ContractVel_PETs, [], 2);

        Max_FrShort = max(FrShort_PETs, [], 2);
        FrShort_50_exact = Max_FrShort * 0.5; %vector containing 50% of max fr shortening values for each PET
        FrShort_20_exact = Max_FrShort * 0.2; 
        FrShort_80_exact = Max_FrShort * 0.8; 
       
        % find the index frame for when contraction nearest 50% max
        % fractional shortening for each PET
        distCon50 = nan(num_events,PET_Win_Con);
        for j = 1:num_events
            distCon50(j, :) = abs (FrShort_50_exact(j) - ContractFrShort_PETs(j,:)); 
            minDistCon50(j) = min(distCon50(j,:), [],2);
            Con50index(j) = min(find(distCon50(j, :) == minDistCon50(j)));
        end
        
        % find the index frame for when contraction nearest 20% max
        % fractional shortening for each PET
        distCon20 = nan(num_events,PET_Win_Con);
        for j = 1:num_events
            distCon20(j, :) = abs (FrShort_20_exact(j) - ContractFrShort_PETs(j,:)); 
            minDistCon20(j) = min(distCon20(j,:), [],2);
            Con20index(j) = min(find(distCon20(j, :) == minDistCon20(j)));
        end
        
        % find the index frame for when contraction nearest 80% max
        % fractional shortening for each PET
        distCon80 = nan(num_events,PET_Win_Con);
        for j = 1:num_events
            distCon80(j, :) = abs (FrShort_80_exact(j) - ContractFrShort_PETs(j,:)); 
            minDistCon80(j) = min(distCon80(j,:), [],2);
            Con80index(j) = min(find(distCon80(j, :) == minDistCon80(j)));
        end
        
        %relaxation only
        for j = 1:num_events
            RelFrShort_PETs(j, :) = delta_norLength(onsets(j) + PET_Win_Con : onsets(j) + PET_Win -1);
        end
        for j = 1:num_events
            RelaxVel_PETs(j, :) = SpeedAll(onsets(j) + PET_Win_Con : onsets(j) + PET_Win -1);
        end  
        Max_RelaxVel = max(RelaxVel_PETs, [], 2);
        
        % find the index frame for when relaxation nearest 50% max
        % fractional shortening for each PET
        distRel50 = nan(num_events,PET_Win_Rel);
        for j = 1:num_events
            distRel50(j, :) = abs (FrShort_50_exact(j) - RelFrShort_PETs(j, :)); 
            minDistRel50(j) = min(distRel50(j,:), [],2);
            Rel50index(j) = min(find(distRel50(j, :) == minDistRel50(j)));
        end

        % find the index frame for when relaxation nearest 20% max
        % fractional shortening for each PET
        distRel20 = nan(num_events,PET_Win_Rel);
        for j = 1:num_events
            distRel20(j, :) = abs (FrShort_20_exact(j) - RelFrShort_PETs(j, :)); 
            minDistRel20(j) = min(distRel20(j,:), [],2);
            Rel20index(j) = min(find(distRel20(j, :) == minDistRel20(j)));
        end
     
        % find the index frame for when relaxation nearest 80% max
        % fractional shortening for each PET
        distRel80 = nan(num_events,PET_Win_Rel);
        for j = 1:num_events
            distRel80(j, :) = abs (FrShort_80_exact(j) - RelFrShort_PETs(j, :)); 
            minDistRel80(j) = min(distRel80(j,:), [],2);
            Rel80index(j) = min(find(distRel80(j, :) == minDistRel80(j)));
        end
        
        %Calculate values for merged contractions by averaging the values
        %registered around the max displacement for each contraction
        mean_FrShort_PETs = mean(FrShort_PETs, 1)';
        mean_Speed_PETs = mean(Speed_PETs, 1)';
        mean_Accel_PETs = mean(Accel_PETs, 1)';
        mean_Symme_PETs = mean(Symme_PETs, 1)';
        
        sem_FrShort_PETs = (std(FrShort_PETs, [], 1)./ sqrt(num_maxima))';
        sem_Speed_PETs = (std(Speed_PETs, [], 1)./ sqrt(num_maxima))';
        sem_Accel_PETs = (std(Accel_PETs, [], 1)./ sqrt(num_maxima))';
        sem_Symme_PETs = (std(Symme_PETs, [], 1)./ sqrt(num_maxima))';
        
        median_max_FrShort = median(max(FrShort_PETs, [], 2));
        median_min_Length = median(min(FrShort_PETs, [], 2));
        avg_max_Speed = mean(max(Speed_PETs, [], 2));
        avg_max_Accel = mean(max(Accel_PETs, [], 2));
        avg_max_Symme = mean(max(Symme_PETs, [], 2));
        
        std_max_FrShort = std(max(FrShort_PETs, [], 2));
        std_min_Length = std(min(FrShort_PETs, [], 2));
        std_max_Speed = std(max(Speed_PETs, [], 2));
        std_max_Accel = std(max(Accel_PETs, [], 2));
        std_max_Symme = std(max(Symme_PETs, [], 2));
        
        %Separately calculate values for each contraction
        Cont1_FrShort = Max_FrShort(1);
        if num_events>1
            Cont2_FrShort = Max_FrShort(2);
        else Cont2_FrShort = NaN;
        end
        if num_events>2
            Cont3_FrShort = Max_FrShort(3);
        else Cont3_FrShort = NaN;
        end 
        if num_events>3
            Cont4_FrShort = Max_FrShort(4);
        else Cont4_FrShort = NaN;
        end
        if num_events>4
            Cont5_FrShort = Max_FrShort(5);
        else Cont5_FrShort = NaN;
        end
        Max_ContractVel = max(ContractVel_PETs, [], 2);
        Cont1_ContractVel50 = Max_ContractVel(1);
        Cont2_ContractVel50 = Max_ContractVel(2);
        if num_events>2
            Cont3_ContractVel = Max_ContractVel(3);
        else Cont3_ContractVel = NaN;
        end
        if num_events>3
            Cont4_ContractVel = Max_ContractVel(4);
        else Cont4_ContractVel = NaN;
        end
        if num_events>4
            Cont5_ContractVel = Max_ContractVel(5);
        else Cont5_ContractVel = NaN;
        end
        
        Max_ContractAccel = max(ContractAccel_PETs, [], 2);
        Cont1_ContractAccel = Max_ContractAccel(1);
        Cont2_ContractAccel = Max_ContractAccel(2);
        if num_events>2
            Cont3_ContractAccel = Max_ContractAccel(3);
        else Cont3_ContractAccel = NaN;
        end
        if num_events>3
            Cont4_ContractAccel = Max_ContractAccel(4);
        else Cont4_ContractAccel = NaN;
        end
        if num_events>4
            Cont5_ContractAccel = Max_ContractAccel(5);
        else Cont5_ContractAccel = NaN;
        end
        
        Max_RelaxVel = max(RelaxVel_PETs, [], 2);
        Cont1_RelaxVel50 = Max_RelaxVel(1);
        Cont2_RelaxVel50 = Max_RelaxVel(2);
        if num_events>2
            Cont3_RelaxVel50 = Max_RelaxVel(3);
        else Cont3_RelaxVel50 = NaN;
        end
        if num_events>3
            Cont4_RelaxVel50 = Max_RelaxVel(4);
        else Cont4_RelaxVel50 = NaN;
        end
        if num_events>4
            Cont5_RelaxVel50 = Max_RelaxVel(5);
        else Cont5_RelaxVel50 = NaN;
        end
        
        median_max_Contract_Vel = median(max(ContractVel_PETs, [], 2));
        median_max_ContractAccel = median(max(ContractAccel_PETs, [], 2));
        median_max_Relax_Vel = median(max(RelaxVel_PETs, [], 2));
        
        std_max_Contract_Vel = std(max(ContractVel_PETs, [], 2));
        std_max_ContractAccel = std(max(ContractAccel_PETs, [], 2));
        std_max_Relax_Vel = std(max(RelaxVel_PETs, [], 2));
        
        % Calculate half-duration or Full-Width at Half-Maximum (FWHM) of
        % length displacement
        
    %    half_duration_PETs = zeros(size(FrShort_PETs),'single');
    %    for j = 1:num_events
    %        nor_delta_Length_PETs(j, :) = nor_delta_norLength(event_ts(j)-TRACE_WIN/2 : event_ts(j)+TRACE_WIN*2-1);
    %    end
    %    for j = 1:num_events
    %    half_duration_PETs(j,:) = nor_delta_Length_PETs(j, :) > max(nor_delta_Length_PETs(j, :),[],2)/2 ;
    %    end
    %    half_durations = sum(half_duration_PETs,2)*SamplingInterval
    %    avg_half_duration = mean(half_durations);
    %    std_half_duration = std(half_durations);
        
        % plot final figures
        
        %% Time Vectors
        % Calculate Time vector (because time is cut out between PET windows)
        % Length of thresh_triggering_signal is the number of frames
        % captured
        timelength = 1:length(thresh_triggering_signal);
        % account for capture frequency to creat a time vector for the time
        % at each frame
        TotalTime = timelength * SamplingInterval;
        
        %% Contraction Time Analysis in um/sec
        % The first event calculations are annotated to make the logic
        % utilized easier to be followed. The other events do not have
        % full annotations.
        
        % Cont 1 contraction Linearization (y=mx+b)
        % Find index in ContractVel_PETs where contraction velocity is max
        
        %Cont1_maxContVel_index = find(ContractVel_PETs(1,:) == Cont1_ContractVel);
        
        ContractVel50 = nan(num_events);
        ContractVel20 = nan(num_events);
        ContractVel80 = nan(num_events);
        
        Cont1_Cont50Vel_index = Con50index(1);
        Cont1_Cont20Vel_index = Con20index(1);
        Cont1_Cont80Vel_index = Con80index(1);
        
        % Cont1_index_conversion is a conversion index from FrShort_PETs
        % that is a valid input index into the delta_norLength vector
        Cont1_index_conversion50 = strfind(delta_norLength,FrShort_PETs(1,:)) + Cont1_Cont50Vel_index - 1;
%         Cont1_index_conversion20 = strfind(delta_norLength,FrShort_PETs(2,:)) + Cont1_Cont20Vel_index - 1;
%         Cont1_index_conversion80 = strfind(delta_norLength,FrShort_PETs(3,:)) + Cont1_Cont80Vel_index - 1;
        Cont1_index_conversion20 = strfind(delta_norLength,FrShort_PETs(1,:)) + Cont1_Cont20Vel_index - 1;
        Cont1_index_conversion80 = strfind(delta_norLength,FrShort_PETs(1,:)) + Cont1_Cont80Vel_index - 1;
        
        % Collect 3 points centered at index of velocity at 50% max contraction in
        % displacement and time to develop a Linear regression model
        Cont1_PreRegrPts = delta_norLength(Cont1_index_conversion50 - 1: Cont1_index_conversion50 +1);
        Cont1_PregRegrTime = TotalTime(Cont1_index_conversion50 - 1: Cont1_index_conversion50 +1);
        Cont1_LinFit = fitlm(Cont1_PregRegrTime,Cont1_PreRegrPts);
        Cont1_LinCoeff = Cont1_LinFit.Coefficients.Estimate;
        Cont1_B = Cont1_LinCoeff(1,1);
        Cont1_m = Cont1_LinCoeff(2,1);
        Cont1_ContractVel50 = Cont1_m;
        ContractVel50 = [Cont1_ContractVel50];
        Cont1_LinRegr = ((Cont1_m) * TotalTime) + Cont1_B;
        
        % Collect 3 points centered at index of velocity at 20% max contraction in
        % displacement and time to develop a Linear regression model        
        Cont1_PreRegrPts20 = delta_norLength(Cont1_index_conversion20 - 1: Cont1_index_conversion20 +1);
        Cont1_PregRegrTime20 = TotalTime(Cont1_index_conversion20 - 1: Cont1_index_conversion20 +1);
        Cont1_LinFit20 = fitlm(Cont1_PregRegrTime20,Cont1_PreRegrPts20);
        Cont1_LinCoeff20 = Cont1_LinFit20.Coefficients.Estimate;
        Cont1_B20 = Cont1_LinCoeff20(1,1);
        Cont1_m20 = Cont1_LinCoeff20(2,1);
        Cont1_ContractVel20 = Cont1_m20;
        ContractVel20 = [Cont1_ContractVel20];
        Cont1_LinRegr20 = ((Cont1_m20) * TotalTime) + Cont1_B20;
        
        % Collect 3 points centered at index of velocity at 80% max contraction in
        % displacement and time to develop a Linear regression model        
        Cont1_PreRegrPts80 = delta_norLength(Cont1_index_conversion80 - 1: Cont1_index_conversion80 +1);
        Cont1_PregRegrTime80 = TotalTime(Cont1_index_conversion80 - 1: Cont1_index_conversion80 +1);
        Cont1_LinFit80 = fitlm(Cont1_PregRegrTime80,Cont1_PreRegrPts80);
        Cont1_LinCoeff80 = Cont1_LinFit80.Coefficients.Estimate;
        Cont1_B80 = Cont1_LinCoeff80(1,1);
        Cont1_m80 = Cont1_LinCoeff80(2,1);
        Cont1_ContractVel80 = Cont1_m80;
        ContractVel80 = [Cont1_ContractVel80];
        Cont1_LinRegr80 = ((Cont1_m80) * TotalTime) + Cont1_B80;

      
        % Find approximate time where contraction starts using linear regression 
        % (if y= mt + b and y=0, t=-b/m). Contraction end is at peak
        % contraction. Contraction time is therefore the difference in
        % these times
        Cont1_start = (-1 * Cont1_B)/ Cont1_m;
        Cont1_end = TotalTime(local_maxima(1));
        Cont1_time = Cont1_end - Cont1_start;
        
        % Contraction 1 Deceleration Time
        % Estimate start of contraction deceleration to be when the 3 points following the  
        % index of max contraction velocity has >10% deviation from the 3 points centered at index of max vel
        % (Points in terms of displacement) 
        % (moving average to determine deviation in displacement)
        for j = Cont1_index_conversion50:10000
            avg_C1_a = mean(SpeedAll(j:j+2));
            avg_C1_b = mean(SpeedAll(Cont1_index_conversion50-2:Cont1_index_conversion50+2));
            ratio_C1 = avg_C1_a / avg_C1_b;
            if ratio_C1 <= 0.9 
            % check if successive avg is also 10 percent deviation
            % (Accounts for possible noise)
                avg_C1_a = mean(SpeedAll(j+1:j+3));
                avg_C1_b = mean(SpeedAll(Cont1_index_conversion50-2:Cont1_index_conversion50+2));
                ratio_C1 = avg_C1_a / avg_C1_b;
                if ratio_C1 <= 0.9
                    Cont1_Decel_start = j+1;
                    break
                end
            end
         end
         Cont1_Decel_time = Cont1_end - TotalTime(Cont1_Decel_start);
         
         % Cont 2 contraction Linearization (y=mx+b)
         if num_events > 1
            %Cont2_maxContVel_index = find(ContractVel_PETs(2,:) == Cont2_ContractVel);
            Cont2_maxContVel_index = Con50index(2);
            Cont2_index_conversion = strfind(delta_norLength,FrShort_PETs(2,:)) + Cont2_maxContVel_index - 1;
            Cont2_Cont20Vel_index = Con20index(2);
            Cont2_Cont80Vel_index = Con80index(2);
            Cont2_index_conversion20 = strfind(delta_norLength,FrShort_PETs(2,:)) + Cont2_Cont20Vel_index - 1;
            Cont2_index_conversion80 = strfind(delta_norLength,FrShort_PETs(2,:)) + Cont2_Cont80Vel_index - 1;
            Cont2_PreRegrPts = delta_norLength(Cont2_index_conversion - 1: Cont2_index_conversion +1);
            Cont2_PregRegrTime = TotalTime(Cont2_index_conversion - 1: Cont2_index_conversion +1);
            %Cont2_PregRegrTime = Cont2_Times_vector(1,Cont2_maxContVel_index - 2: Cont2_maxContVel_index +2);
            Cont2_LinFit = fitlm(Cont2_PregRegrTime,Cont2_PreRegrPts);
            Cont2_LinCoeff = Cont2_LinFit.Coefficients.Estimate;
            Cont2_B = Cont2_LinCoeff(1,1);
            Cont2_m = Cont2_LinCoeff(2,1);
            Cont2_ContractVel50 = Cont2_m;
            ContractVel50 = [ContractVel50, Cont2_ContractVel50];
            Cont2_LinRegr = ((Cont2_m) * TotalTime) + Cont2_B;
              
        Cont2_PreRegrPts20 = delta_norLength(Cont2_index_conversion20 - 1: Cont2_index_conversion20 +1);
        Cont2_PregRegrTime20 = TotalTime(Cont2_index_conversion20 - 1: Cont2_index_conversion20 +1);
        Cont2_LinFit20 = fitlm(Cont2_PregRegrTime20,Cont2_PreRegrPts20);
        Cont2_LinCoeff20 = Cont2_LinFit20.Coefficients.Estimate;
        Cont2_B20 = Cont2_LinCoeff20(1,1);
        Cont2_m20 = Cont2_LinCoeff20(2,1);
        Cont2_ContractVel20 = Cont2_m20;
        ContractVel20 = [ContractVel20, Cont2_ContractVel20];
        Cont2_LinRegr20 = ((Cont2_m20) * TotalTime) + Cont2_B20;       
        Cont2_PreRegrPts80 = delta_norLength(Cont2_index_conversion80 - 1: Cont2_index_conversion80 +1);
        Cont2_PregRegrTime80 = TotalTime(Cont2_index_conversion80 - 1: Cont2_index_conversion80 +1);
        Cont2_LinFit80 = fitlm(Cont2_PregRegrTime80,Cont2_PreRegrPts80);
        Cont2_LinCoeff80 = Cont2_LinFit80.Coefficients.Estimate;
        Cont2_B80 = Cont2_LinCoeff80(1,1);
        Cont2_m80 = Cont2_LinCoeff80(2,1);
        Cont2_ContractVel80 = Cont2_m80;
        ContractVel80 = [Cont2_ContractVel80];
        Cont2_LinRegr80 = ((Cont2_m80) * TotalTime) + Cont2_B80;

            Cont2_start = (-1 * Cont2_B)/ Cont2_m;
            Cont2_end = TotalTime(local_maxima(2));
            Cont2_time = Cont2_end - Cont2_start;
            % Cont 2 Decel 10% deviation fr max vel
            for j = Cont2_index_conversion:10000
                avg_C2_a = mean(SpeedAll(j:j+2));
                avg_C2_b = mean(SpeedAll(Cont2_index_conversion-2:Cont2_index_conversion+2));
                ratio_C2 = avg_C2_a / avg_C2_b;
                if ratio_C2 <= 0.9 %10 percent deviation avg of max vel
                % check if successive avg is also 10 percent deviation
                    avg_C2_a = mean(SpeedAll(j+1:j+3));
                    avg_C2_b = mean(SpeedAll(Cont2_index_conversion-2:Cont2_index_conversion+2));
                    ratio_C2 = avg_C2_a / avg_C2_b;
                    if ratio_C2 <= 0.9
                        Cont2_Decel_start = j+1;
                        break
                    end
                end
                %j = j+1;
            end
            Cont2_Decel_time = Cont2_end - TotalTime(Cont2_Decel_start);
        else
            Cont2_time = NaN;
            Cont2_Decel_time = NaN;
            Cont2_ContractVel50 = NaN;
        end
         
         % Cont 3 contraction Linearization (y=mx+b)
         if num_events > 2
            %Cont3_maxContVel_index = find(ContractVel_PETs(3,:) == Cont3_ContractVel);
            Cont3_maxContVel_index = Con50index(3);
            Cont3_index_conversion = strfind(delta_norLength,FrShort_PETs(3,:)) + Cont3_maxContVel_index - 1;
            Cont3_Cont20Vel_index = Con20index(3);
            Cont3_Cont80Vel_index = Con80index(3);
            Cont3_index_conversion20 = strfind(delta_norLength,FrShort_PETs(3,:)) + Cont3_Cont20Vel_index - 1;
            Cont3_index_conversion80 = strfind(delta_norLength,FrShort_PETs(3,:)) + Cont3_Cont80Vel_index - 1;
            Cont3_PreRegrPts = delta_norLength(Cont3_index_conversion - 1: Cont3_index_conversion +1);
            Cont3_PregRegrTime = TotalTime(Cont3_index_conversion - 1: Cont3_index_conversion +1);
            Cont3_LinFit = fitlm(Cont3_PregRegrTime,Cont3_PreRegrPts);
            Cont3_LinCoeff = Cont3_LinFit.Coefficients.Estimate;
            Cont3_B = Cont3_LinCoeff(1,1);
            Cont3_m = Cont3_LinCoeff(2,1);
            Cont3_ContractVel50 = Cont3_m;
            ContractVel50 = [ContractVel50, Cont3_ContractVel50];
            Cont3_ContractVel50 = Cont3_m;
            Cont3_LinRegr = ((Cont3_m) * TotalTime) + Cont3_B;
                    
        Cont3_PreRegrPts20 = delta_norLength(Cont3_index_conversion20 - 1: Cont3_index_conversion20 +1);
        Cont3_PregRegrTime20 = TotalTime(Cont3_index_conversion20 - 1: Cont3_index_conversion20 +1);
        Cont3_LinFit20 = fitlm(Cont3_PregRegrTime20,Cont3_PreRegrPts20);
        Cont3_LinCoeff20 = Cont3_LinFit20.Coefficients.Estimate;
        Cont3_B20 = Cont3_LinCoeff20(1,1);
        Cont3_m20 = Cont3_LinCoeff20(2,1);
        Cont3_ContractVel20 = Cont3_m20;
        ContractVel20 = [ContractVel20, Cont3_ContractVel20];
        Cont3_LinRegr20 = ((Cont3_m20) * TotalTime) + Cont3_B20;       
        Cont3_PreRegrPts80 = delta_norLength(Cont3_index_conversion80 - 1: Cont3_index_conversion80 +1);
        Cont3_PregRegrTime80 = TotalTime(Cont3_index_conversion80 - 1: Cont3_index_conversion80 +1);
        Cont3_LinFit80 = fitlm(Cont3_PregRegrTime80,Cont3_PreRegrPts80);
        Cont3_LinCoeff80 = Cont3_LinFit80.Coefficients.Estimate;
        Cont3_B80 = Cont3_LinCoeff80(1,1);
        Cont3_m80 = Cont3_LinCoeff80(2,1);
        Cont3_ContractVel80 = Cont3_m80;
        ContractVel80 = [Cont3_ContractVel80];
        Cont3_LinRegr80 = ((Cont3_m80) * TotalTime) + Cont3_B80;
        
            Cont3_start = (-1 * Cont3_B)/ Cont3_m;
            Cont3_end = TotalTime(local_maxima(3));
            Cont3_time = Cont3_end - Cont3_start;
            % Cont 3 Decel 10% deviation fr max vel
            for j = Cont3_index_conversion:10000
                avg_C3_a = mean(SpeedAll(j:j+2));
                avg_C3_b = mean(SpeedAll(Cont3_index_conversion-2:Cont3_index_conversion+2));
                ratio_C3 = avg_C3_a / avg_C3_b;
                if ratio_C3 <= 0.9 %10 percent deviation avg of max vel
                % check if successive avg is also 10 percent deviation
                    avg_C3_a = mean(SpeedAll(j+1:j+3));
                    avg_C3_b = mean(SpeedAll(Cont3_index_conversion-2:Cont3_index_conversion+2));
                    ratio_C3 = avg_C3_a / avg_C3_b;
                    if ratio_C3 <= 0.9
                        Cont3_Decel_start = j+1;
                        break
                    end
                end
                %j = j+1;
            end
            Cont3_Decel_time = Cont3_end - TotalTime(Cont3_Decel_start);
         else
            Cont3_time = NaN;
            Cont3_Decel_time = NaN;
            Cont3_ContractVel50 = NaN;
         end
         
         % Cont 4 contraction Linearization (y=mx+b)
         if num_events > 3
            %Cont4_maxContVel_index = find(ContractVel_PETs(4,:) == Cont4_ContractVel);
            Cont4_maxContVel_index = Con50index(4);
            Cont4_index_conversion = strfind(delta_norLength,FrShort_PETs(4,:)) + Cont4_maxContVel_index - 1;
            Cont4_Cont20Vel_index = Con20index(4);
            Cont4_Cont80Vel_index = Con80index(4);
            Cont4_index_conversion20 = strfind(delta_norLength,FrShort_PETs(4,:)) + Cont4_Cont20Vel_index - 1;
            Cont4_index_conversion80 = strfind(delta_norLength,FrShort_PETs(4,:)) + Cont4_Cont80Vel_index - 1;
            Cont4_PreRegrPts = delta_norLength(Cont4_index_conversion - 1: Cont4_index_conversion +1);
            Cont4_PregRegrTime = TotalTime(Cont4_index_conversion - 1: Cont4_index_conversion +1);
            Cont4_LinFit = fitlm(Cont4_PregRegrTime,Cont4_PreRegrPts);
            Cont4_LinCoeff = Cont4_LinFit.Coefficients.Estimate;
            Cont4_B = Cont4_LinCoeff(1,1);
            Cont4_m = Cont4_LinCoeff(2,1);
            Cont4_ContractVel50 = Cont4_m;
            ContractVel50 = [ContractVel50, Cont4_ContractVel50];
            Cont4_LinRegr = ((Cont4_m) * TotalTime) + Cont4_B;
            
        Cont4_PreRegrPts20 = delta_norLength(Cont4_index_conversion20 - 1: Cont4_index_conversion20 +1);
        Cont4_PregRegrTime20 = TotalTime(Cont4_index_conversion20 - 1: Cont4_index_conversion20 +1);
        Cont4_LinFit20 = fitlm(Cont4_PregRegrTime20,Cont4_PreRegrPts20);
        Cont4_LinCoeff20 = Cont4_LinFit20.Coefficients.Estimate;
        Cont4_B20 = Cont4_LinCoeff20(1,1);
        Cont4_m20 = Cont4_LinCoeff20(2,1);
        Cont4_ContractVel20 = Cont4_m20;
        ContractVel20 = [ContractVel20, Cont4_ContractVel20];
        Cont4_LinRegr20 = ((Cont4_m20) * TotalTime) + Cont4_B20;       
        Cont4_PreRegrPts80 = delta_norLength(Cont4_index_conversion80 - 1: Cont4_index_conversion80 +1);
        Cont4_PregRegrTime80 = TotalTime(Cont4_index_conversion80 - 1: Cont4_index_conversion80 +1);
        Cont4_LinFit80 = fitlm(Cont4_PregRegrTime80,Cont4_PreRegrPts80);
        Cont4_LinCoeff80 = Cont4_LinFit80.Coefficients.Estimate;
        Cont4_B80 = Cont4_LinCoeff80(1,1);
        Cont4_m80 = Cont4_LinCoeff80(2,1);
        Cont4_ContractVel80 = Cont4_m80;
        ContractVel80 = [Cont4_ContractVel80];
        Cont4_LinRegr80 = ((Cont4_m80) * TotalTime) + Cont4_B80;
        
            Cont4_start = (-1 * Cont4_B)/ Cont4_m;
            Cont4_end = TotalTime(local_maxima(4));
            Cont4_time = Cont4_end - Cont4_start;
            % Cont 4 Decel 10% deviation fr max vel
            for j = Cont4_index_conversion:10000
                avg_C4_a = mean(SpeedAll(j:j+2));
                avg_C4_b = mean(SpeedAll(Cont4_index_conversion-2:Cont4_index_conversion+2));
                ratio_C4 = avg_C4_a / avg_C4_b;
                if ratio_C4 <= 0.9 %10 percent deviation avg of max vel
                % check if successive avg is also 10 percent deviation
                    avg_C4_a = mean(SpeedAll(j+1:j+3));
                    avg_C4_b = mean(SpeedAll(Cont4_index_conversion-2:Cont4_index_conversion+2));
                    ratio_C4 = avg_C4_a / avg_C4_b;
                    if ratio_C4 <= 0.9
                        Cont4_Decel_start = j+1;
                        break
                    end
                end
                %j = j+1;
            end
            Cont4_Decel_time = Cont4_end - TotalTime(Cont4_Decel_start);
         else
            Cont4_time = NaN;
            Cont4_Decel_time = NaN;
            Cont4_ContractVel50 = NaN;
         end
         
         % Cont 5 contraction Linearization (y=mx+b)
         
         if num_events > 4
            %Cont5_maxContVel_index = find(ContractVel_PETs(5,:) == Cont5_ContractVel);
            Cont5_maxContVel_index = Con50index(5);
            Cont5_index_conversion = strfind(delta_norLength,FrShort_PETs(5,:)) + Cont5_maxContVel_index - 1;
            Cont5_Cont20Vel_index = Con20index(5);
            Cont5_Cont80Vel_index = Con80index(5);
            Cont5_index_conversion20 = strfind(delta_norLength,FrShort_PETs(5,:)) + Cont5_Cont20Vel_index - 1;
            Cont5_index_conversion80 = strfind(delta_norLength,FrShort_PETs(5,:)) + Cont5_Cont80Vel_index - 1;
            Cont5_PreRegrPts = delta_norLength(Cont5_index_conversion - 1: Cont5_index_conversion +1);
            Cont5_PregRegrTime = TotalTime(Cont5_index_conversion - 1: Cont5_index_conversion +1);
            Cont5_LinFit = fitlm(Cont5_PregRegrTime,Cont5_PreRegrPts);
            Cont5_LinCoeff = Cont5_LinFit.Coefficients.Estimate;
            Cont5_B = Cont5_LinCoeff(1,1);
            Cont5_m = Cont5_LinCoeff(2,1);
            Cont5_ContractVel50 = Cont5_m;
            ContractVel50 = [ContractVel50, Cont5_ContractVel50];
            Cont5_LinRegr = ((Cont5_m) * TotalTime) + Cont5_B;
            
        Cont5_PreRegrPts20 = delta_norLength(Cont5_index_conversion20 - 1: Cont5_index_conversion20 +1);
        Cont5_PregRegrTime20 = TotalTime(Cont5_index_conversion20 - 1: Cont5_index_conversion20 +1);
        Cont5_LinFit20 = fitlm(Cont5_PregRegrTime20,Cont5_PreRegrPts20);
        Cont5_LinCoeff20 = Cont5_LinFit20.Coefficients.Estimate;
        Cont5_B20 = Cont5_LinCoeff20(1,1);
        Cont5_m20 = Cont5_LinCoeff20(2,1);
        Cont5_ContractVel20 = Cont5_m20;
        ContractVel20 = [ContractVel20, Cont5_ContractVel20];
        Cont5_LinRegr20 = ((Cont5_m20) * TotalTime) + Cont5_B20;       
        Cont5_PreRegrPts80 = delta_norLength(Cont5_index_conversion80 - 1: Cont5_index_conversion80 +1);
        Cont5_PregRegrTime80 = TotalTime(Cont5_index_conversion80 - 1: Cont5_index_conversion80 +1);
        Cont5_LinFit80 = fitlm(Cont5_PregRegrTime80,Cont5_PreRegrPts80);
        Cont5_LinCoeff80 = Cont5_LinFit80.Coefficients.Estimate;
        Cont5_B80 = Cont5_LinCoeff80(1,1);
        Cont5_m80 = Cont5_LinCoeff80(2,1);
        Cont5_ContractVel80 = Cont5_m80;
        ContractVel80 = [Cont5_ContractVel80];
        Cont5_LinRegr80 = ((Cont5_m80) * TotalTime) + Cont5_B80;
        
            Cont5_start = (-1 * Cont5_B)/ Cont5_m;
            Cont5_end = TotalTime(local_maxima(5));
            Cont5_time = Cont5_end - Cont5_start;
            % Cont 5 Decel 10% deviation fr max vel
            for j = Cont5_index_conversion:10000
                avg_C5_a = mean(SpeedAll(j:j+2));
                avg_C5_b = mean(SpeedAll(Cont5_index_conversion-2:Cont5_index_conversion+2));
                ratio_C5 = avg_C5_a / avg_C5_b;
                if ratio_C5 <= 0.9 %10 percent deviation avg of max vel
                % check if successive avg is also 10 percent deviation
                    avg_C5_a = mean(SpeedAll(j:j+2));
                    avg_C5_b = mean(SpeedAll(Cont5_index_conversion-2:Cont5_index_conversion+2));
                    ratio_C5 = avg_C5_a / avg_C5_b;
                    if ratio_C5 <= 0.9
                        Cont5_Decel_start = j+1;
                        break
                    end
                end
                %j = j+1;
            end
            Cont5_Decel_time = Cont5_end - TotalTime(Cont5_Decel_start);
         else
            Cont5_time = NaN;
            Cont5_Decel_time = NaN;
            Cont5_ContractVel50 = NaN;
         end
         

    
         %% Relaxation Time Analysis
         % The first event calculations are annotated to make the logic
         % utilized easier to be followed. The other events do not have
         % full annotations.
         
         % RelVel_VecShift is a conversion to sum with indices from
         % RelaxVel_PETs to find a valid input index into FrShort_PETs
         % (Same conversion value for all events)
            %RelVel_VecShift = length(ContractVel_PETs(1,:));   
            RelVel50 = nan(num_events);
            RelVel20 = nan(num_events);
            RelVel80 = nan(num_events);
            
            RelVel_VecShift = PET_Win_Con;
            % Cont 1 relaxation Linearization (y=mx+b)
            % Find index in RelaxVel_PETs where relaxation velocity is max
            %Rel1_maxRelVel_index = find(RelaxVel_PETs(1,:) == Cont1_RelaxVel) + RelVel_VecShift;
            Rel1_maxRelVel_index = Rel50index(1) + RelVel_VecShift;
            Rel1_Rel20Vel_index = Rel20index(1) + RelVel_VecShift;
            Rel1_Rel80Vel_index = Rel80index(1) + RelVel_VecShift;
            
            % Rel1_index_conversion is a conversion index from FrShort_PETs
            % that is a valid input index into the delta_norLength vector
            Rel1_index_conversion = strfind(delta_norLength,FrShort_PETs(1,:)) + Rel1_maxRelVel_index - 1;
            Rel1_index_conversion20 = strfind(delta_norLength,FrShort_PETs(1,:)) + Rel1_Rel20Vel_index - 1;
            Rel1_index_conversion80 = strfind(delta_norLength,FrShort_PETs(1,:)) + Rel1_Rel80Vel_index - 1;
            
            % Collect 3 points centered at index of max velocity in
            % displacement and time to develop a Linear regression model to
            % use as estimates for when the contraction event starts and
            % ends (approximately where displacement approaches zero)
            %Rel1_PreRegrPts = delta_norLength(1,Rel1_index_conversion - 1: Rel1_index_conversion + 1);
            Rel1_PreRegrPts = delta_norLength(Rel1_index_conversion - 1: Rel1_index_conversion + 1);
            Rel1_PregRegrTime = TotalTime(Rel1_index_conversion - 1: Rel1_index_conversion +1);
            Rel1_LinFit = fitlm(Rel1_PregRegrTime,Rel1_PreRegrPts);
            Rel1_LinCoeff = Rel1_LinFit.Coefficients.Estimate;
            Rel1_B = Rel1_LinCoeff(1,1);
            Rel1_m = Rel1_LinCoeff(2,1);
            Rel1_RelaxVel50 = Rel1_m;
            RelVel50 = [Rel1_RelaxVel50];
            Rel1_LinRegr = ((Rel1_m) * TotalTime) + Rel1_B;
            
            % Collect 3 points centered at index of velocity to 20% of max contraction in
            % displacement and time to develop a Linear regression model
            %Rel1_PreRegrPts20 = delta_norLength(1,Rel1_index_conversion20 - 1: Rel1_index_conversion20 + 1);
            Rel1_PreRegrPts20 = delta_norLength(Rel1_index_conversion20 - 1: Rel1_index_conversion20 + 1);
            Rel1_PregRegrTime20 = TotalTime(Rel1_index_conversion20 - 1: Rel1_index_conversion20 +1);
            Rel1_LinFit20 = fitlm(Rel1_PregRegrTime20,Rel1_PreRegrPts20);
            Rel1_LinCoeff20 = Rel1_LinFit20.Coefficients.Estimate;
            Rel1_B20 = Rel1_LinCoeff20(1,1);
            Rel1_m20 = Rel1_LinCoeff20(2,1);
            Rel1_RelaxVel20 = Rel1_m20;
            RelVel20 = [Rel1_RelaxVel20];
            Rel1_LinRegr20 = ((Rel1_m20) * TotalTime) + Rel1_B20;
            % Collect 3 points centered at index of velocity to 80% of max contraction in
            % displacement and time to develop a Linear regression model
            % Rel1_PreRegrPts80 = delta_norLength(1,Rel1_index_conversion80 - 1: Rel1_index_conversion80 + 1);
            Rel1_PreRegrPts80 = delta_norLength(Rel1_index_conversion80 - 1: Rel1_index_conversion80 + 1);
            Rel1_PregRegrTime80 = TotalTime(Rel1_index_conversion80 - 1: Rel1_index_conversion80 +1);
            Rel1_LinFit80 = fitlm(Rel1_PregRegrTime80,Rel1_PreRegrPts80);
            Rel1_LinCoeff80 = Rel1_LinFit80.Coefficients.Estimate;
            Rel1_B80 = Rel1_LinCoeff80(1,1);
            Rel1_m80 = Rel1_LinCoeff80(2,1);
            Rel1_RelaxVel80 = Rel1_m80;
            RelVel80 = [Rel1_RelaxVel80];
            Rel1_LinRegr80 = ((Rel1_m80) * TotalTime) + Rel1_B80;
            
            % Find approximate time where relaxtion ends using linear regression 
            % (if y= mt + b and y=0, t=-b/m). Relaxation start is at peak
            % contraction. Relaxation time is therefore the difference in
            % these times
            Rel1_end = (-1 * Rel1_B)/ Rel1_m;
            Rel1_start = TotalTime(local_maxima(1));
            Rel1_time = Rel1_end - Rel1_start;
            
            % Relaxation 1 Acceleration Time
            % Estimate end of relaxation acceleration to be when the 3 points prior to the  
            % index of max relaxation velocity has >10% deviation from the 3 points centered at index of max vel
            % (Points in terms of displacement)
            for j = Rel1_index_conversion:-1:0
                avg_R1_a = mean(SpeedAll(1,j-2:j));
                avg_R1_b = mean(SpeedAll(1,Rel1_index_conversion-1:Rel1_index_conversion+1));
                ratio_R1 = avg_R1_a / avg_R1_b;
                if ratio_R1 <= 0.9 
                % Check if successive avg is also 10 percent deviation
                % (Accounts for possible noise)
                    avg_R1_a = mean(SpeedAll(1,j-3:j-1));
                    avg_R1_b = mean(SpeedAll(1,Rel1_index_conversion-2:Rel1_index_conversion+2));
                    ratio_R1 = avg_R1_a / avg_R1_b;
                    if ratio_R1 <= 0.9
                        Rel1_Accel_end = j+1;
                        break
                    end
                end
            end
            Rel1_Accel_time = TotalTime(Rel1_Accel_end) - Rel1_start;
            
            % Cont 2 relaxation Linearization (y=mx+b)
        if num_events > 1
            Rel2_maxRelVel_index = Rel50index(2) + RelVel_VecShift;
            Rel2_index_conversion = strfind(delta_norLength,FrShort_PETs(2,:)) + Rel2_maxRelVel_index - 1;
            Rel2_Rel20Vel_index = Rel20index(2) + RelVel_VecShift;
            Rel2_Rel80Vel_index = Rel80index(2) + RelVel_VecShift;
            Rel2_index_conversion20 = strfind(delta_norLength,FrShort_PETs(2,:)) + Rel2_Rel20Vel_index - 1;
            Rel2_index_conversion80 = strfind(delta_norLength,FrShort_PETs(2,:)) + Rel2_Rel80Vel_index - 1;
            Rel2_PreRegrPts = delta_norLength(Rel2_index_conversion - 1: Rel2_index_conversion + 1);
            Rel2_PregRegrTime = TotalTime(Rel2_index_conversion - 1: Rel2_index_conversion +1);
            Rel2_LinFit = fitlm(Rel2_PregRegrTime,Rel2_PreRegrPts);
            Rel2_LinCoeff = Rel2_LinFit.Coefficients.Estimate;
            Rel2_B = Rel2_LinCoeff(1,1);
            Rel2_m = Rel2_LinCoeff(2,1);
            Rel2_RelaxVel50 = Rel2_m;
            RelVel50 = [RelVel50, Rel2_RelaxVel50];
            Rel2_LinRegr = ((Rel2_m) * TotalTime) + Rel2_B;
            
            Rel2_PreRegrPts20 = delta_norLength(Rel2_index_conversion20 - 1: Rel2_index_conversion20 + 1);
            Rel2_PregRegrTime20 = TotalTime(Rel2_index_conversion20 - 1: Rel2_index_conversion20 +1);
            Rel2_LinFit20 = fitlm(Rel2_PregRegrTime20,Rel2_PreRegrPts20);
            Rel2_LinCoeff20 = Rel2_LinFit20.Coefficients.Estimate;
            Rel2_B20 = Rel2_LinCoeff20(1,1);
            Rel2_m20 = Rel2_LinCoeff20(2,1);
            Rel2_RelaxVel20 = Rel2_m20;
            RelVel20 = [RelVel20, Rel2_RelaxVel20];
            Rel2_LinRegr20 = ((Rel2_m20) * TotalTime) + Rel2_B20;
            Rel2_PreRegrPts80 = delta_norLength(Rel2_index_conversion80 - 1: Rel2_index_conversion80 + 1);
            Rel2_PregRegrTime80 = TotalTime(Rel2_index_conversion80 - 1: Rel2_index_conversion80 +1);
            Rel2_LinFit80 = fitlm(Rel2_PregRegrTime80,Rel2_PreRegrPts80);
            Rel2_LinCoeff80 = Rel2_LinFit80.Coefficients.Estimate;
            Rel2_B80 = Rel2_LinCoeff80(1,1);
            Rel2_m80 = Rel2_LinCoeff80(2,1);
            Rel2_RelaxVel80 = Rel2_m80;
            RelVel80 = [RelVel80, Rel2_RelaxVel80];
            Rel2_LinRegr80 = ((Rel2_m80) * TotalTime) + Rel2_B80;
            
            %if y= mt + b and y=0, t=-b/m
            Rel2_end = (-1 * Rel2_B)/ Rel2_m;
            Rel2_start = TotalTime(local_maxima(2));
            Rel2_time = Rel2_end - Rel2_start;
%           % Cont 1 Decel 10% deviation fr max vel
            for j = Rel2_index_conversion:-1:0
                avg_R2_a = mean(SpeedAll(j-2:j));
                avg_R2_b = mean(SpeedAll(Rel2_index_conversion-2:Rel2_index_conversion+2));
                ratio_R2 = avg_R2_a / avg_R2_b;
                if ratio_R2 <= 0.9 %10 percent deviation avg of max vel
                % check if successive avg is also 10 percent deviation
                    avg_R2_a = mean(SpeedAll(j-3:j-1));
                    avg_R2_b = mean(SpeedAll(Rel2_index_conversion-2:Rel2_index_conversion+2));
                    ratio_R2 = avg_R2_a / avg_R2_b;
                    if ratio_R2 <= 0.9
                        Rel2_Accel_end = j-1;
                        break
                    end
                end
            end
            Rel2_Accel_time = TotalTime(Rel2_Accel_end) - Rel2_start;
        else
            Rel2_time = NaN;
            Rel2_Accel_time = NaN;
        end
            
        % Cont 3 relaxation Linearization (y=mx+b)
        if num_events > 2
            Rel3_maxRelVel_index = Rel50index(3) + RelVel_VecShift;
            Rel3_index_conversion = strfind(delta_norLength,FrShort_PETs(3,:)) +  Rel3_maxRelVel_index - 1;
            Rel3_Rel20Vel_index = Rel20index(3) + RelVel_VecShift;
            Rel3_Rel80Vel_index = Rel80index(3) + RelVel_VecShift;
            Rel3_index_conversion20 = strfind(delta_norLength,FrShort_PETs(3,:)) + Rel3_Rel20Vel_index - 1;
            Rel3_index_conversion80 = strfind(delta_norLength,FrShort_PETs(3,:)) + Rel3_Rel80Vel_index - 1;
            Rel3_PreRegrPts = delta_norLength(Rel3_index_conversion - 1: Rel3_index_conversion + 1);
            Rel3_PregRegrTime = TotalTime(Rel3_index_conversion - 1: Rel3_index_conversion +1);
            Rel3_LinFit = fitlm(Rel3_PregRegrTime,Rel3_PreRegrPts);
            Rel3_LinCoeff = Rel3_LinFit.Coefficients.Estimate;
            Rel3_B = Rel3_LinCoeff(1,1);
            Rel3_m = Rel3_LinCoeff(2,1);
            Rel3_RelaxVel50 = Rel3_m;
            RelVel50 = [RelVel50, Rel3_RelaxVel50];
            Rel3_LinRegr = ((Rel3_m) * TotalTime) + Rel3_B;
            
            Rel3_PreRegrPts20 = delta_norLength(Rel3_index_conversion20 - 1: Rel3_index_conversion20 + 1);
            Rel3_PregRegrTime20 = TotalTime(Rel3_index_conversion20 - 1: Rel3_index_conversion20 +1);
            Rel3_LinFit20 = fitlm(Rel3_PregRegrTime20,Rel3_PreRegrPts20);
            Rel3_LinCoeff20 = Rel3_LinFit20.Coefficients.Estimate;
            Rel3_B20 = Rel3_LinCoeff20(1,1);
            Rel3_m20 = Rel3_LinCoeff20(2,1);
            Rel3_RelaxVel20 = Rel3_m20;
            RelVel20 = [RelVel20, Rel3_RelaxVel20];
            Rel3_LinRegr20 = ((Rel3_m20) * TotalTime) + Rel3_B20;
            Rel3_PreRegrPts80 = delta_norLength(Rel3_index_conversion80 - 1: Rel3_index_conversion80 + 1);
            Rel3_PregRegrTime80 = TotalTime(Rel3_index_conversion80 - 1: Rel3_index_conversion80 +1);
            Rel3_LinFit80 = fitlm(Rel3_PregRegrTime80,Rel3_PreRegrPts80);
            Rel3_LinCoeff80 = Rel3_LinFit80.Coefficients.Estimate;
            Rel3_B80 = Rel3_LinCoeff80(1,1);
            Rel3_m80 = Rel3_LinCoeff80(2,1);
            Rel3_RelaxVel80 = Rel3_m80;
            RelVel80 = [RelVel80, Rel3_RelaxVel80];
            Rel3_LinRegr80 = ((Rel3_m80) * TotalTime) + Rel3_B80;
            
            %if y= mt + b and y=0, t=-b/m
            Rel3_end = (-1 * Rel3_B)/ Rel3_m;
            Rel3_start = TotalTime(local_maxima(3));
            Rel3_time = Rel3_end - Rel3_start;
%           % Cont 1 Decel 10% deviation fr max vel
            for j = Rel3_index_conversion:-1:0
                avg_R3_a = mean(SpeedAll(j-2:j));
                avg_R3_b = mean(SpeedAll(Rel3_index_conversion-2:Rel3_index_conversion+2));
                ratio_R3 = avg_R3_a / avg_R3_b;
                if ratio_R3 <= 0.9 %10 percent deviation avg of max vel
                % check if successive avg is also 10 percent deviation
                    avg_R3_a = mean(SpeedAll(j-3:j-1));
                    avg_R3_b = mean(SpeedAll(Rel3_index_conversion-2:Rel3_index_conversion+2));
                    ratio_R3 = avg_R3_a / avg_R3_b;
                    if ratio_R3 <= 0.9
                        Rel3_Accel_end = j-1;
                        break
                    end
                end
            end
            Rel3_Accel_time = TotalTime(Rel3_Accel_end) - Rel3_start;
        else
            Rel3_time = NaN;
            Rel3_Accel_time = NaN;
        end
            
        % Cont 4 relaxation Linearization (y=mx+b)
        if num_events > 3
            Rel4_maxRelVel_index = Rel50index(4) + RelVel_VecShift;
            Rel4_index_conversion = strfind(delta_norLength,FrShort_PETs(4,:)) +  Rel4_maxRelVel_index - 1;
            Rel4_Rel20Vel_index = Rel20index(4) + RelVel_VecShift;
            Rel4_Rel80Vel_index = Rel80index(4) + RelVel_VecShift;
            Rel4_index_conversion20 = strfind(delta_norLength,FrShort_PETs(4,:)) + Rel4_Rel20Vel_index - 1;
            Rel4_index_conversion80 = strfind(delta_norLength,FrShort_PETs(4,:)) + Rel4_Rel80Vel_index - 1;
            Rel4_PreRegrPts = delta_norLength(Rel4_index_conversion - 1: Rel4_index_conversion + 1);
            %Rel1_index_conversion = strfind(delta_norLength,Rel1_PreRegrPts) + 2 ;
            Rel4_PregRegrTime = TotalTime(Rel4_index_conversion - 1: Rel4_index_conversion +1);
            Rel4_LinFit = fitlm(Rel4_PregRegrTime,Rel4_PreRegrPts);
            Rel4_LinCoeff = Rel4_LinFit.Coefficients.Estimate;
            Rel4_B = Rel4_LinCoeff(1,1);
            Rel4_m = Rel4_LinCoeff(2,1);
            Rel4_RelaxVel50 = Rel4_m;
            RelVel50 = [RelVel50, Rel4_RelaxVel50];
            Rel4_LinRegr = ((Rel4_m) * TotalTime) + Rel4_B;
            
            Rel4_PreRegrPts20 = delta_norLength(Rel4_index_conversion20 - 1: Rel4_index_conversion20 + 1);
            Rel4_PregRegrTime20 = TotalTime(Rel4_index_conversion20 - 1: Rel4_index_conversion20 +1);
            Rel4_LinFit20 = fitlm(Rel4_PregRegrTime20,Rel4_PreRegrPts20);
            Rel4_LinCoeff20 = Rel4_LinFit20.Coefficients.Estimate;
            Rel4_B20 = Rel4_LinCoeff20(1,1);
            Rel4_m20 = Rel4_LinCoeff20(2,1);
            Rel4_RelaxVel20 = Rel4_m20;
            RelVel20 = [RelVel20, Rel4_RelaxVel20];
            Rel4_LinRegr20 = ((Rel4_m20) * TotalTime) + Rel4_B20;
            Rel4_PreRegrPts80 = delta_norLength(Rel4_index_conversion80 - 1: Rel4_index_conversion80 + 1);
            Rel4_PregRegrTime80 = TotalTime(Rel4_index_conversion80 - 1: Rel4_index_conversion80 +1);
            Rel4_LinFit80 = fitlm(Rel4_PregRegrTime80,Rel4_PreRegrPts80);
            Rel4_LinCoeff80 = Rel4_LinFit80.Coefficients.Estimate;
            Rel4_B80 = Rel4_LinCoeff80(1,1);
            Rel4_m80 = Rel4_LinCoeff80(2,1);
            Rel4_RelaxVel80 = Rel4_m80;
            RelVel80 = [RelVel80, Rel4_RelaxVel80];
            Rel4_LinRegr80 = ((Rel4_m80) * TotalTime) + Rel4_B80;
            
            %if y= mt + b and y=0, t=-b/m
            Rel4_end = (-1 * Rel4_B)/ Rel4_m;
            Rel4_start = TotalTime(local_maxima(4));
            Rel4_time = Rel4_end - Rel4_start;
%           % Cont 1 Decel 10% deviation fr max vel
            for j = Rel4_index_conversion:-1:0
                avg_R4_a = mean(SpeedAll(j-2:j));
                avg_R4_b = mean(SpeedAll(Rel4_index_conversion-2:Rel4_index_conversion+2));
                ratio_R4 = avg_R4_a / avg_R4_b;
                if ratio_R4 <= 0.9 %10 percent deviation avg of max vel
                % check if successive avg is also 10 percent deviation
                    avg_R4_a = mean(SpeedAll(j-3:j-1));
                    avg_R4_b = mean(SpeedAll(Rel4_index_conversion-2:Rel4_index_conversion+2));
                    ratio_R4 = avg_R4_a / avg_R4_b;
                    if ratio_R4 <= 0.9
                        Rel4_Accel_end = j-1;
                        break
                    end
                end
            end
            Rel4_Accel_time = TotalTime(Rel4_Accel_end) - Rel4_start;
        else
            Rel4_time = NaN;
            Rel4_Accel_time = NaN;
        end    
        
        % Cont 5 relaxation Linearization (y=mx+b)
        if num_events > 4
            %Rel5_maxRelVel_index = find(RelaxVel_PETs(5,:) == Cont5_RelaxVel) + RelVel_VecShift;
            Rel5_maxRelVel_index = Rel50index(5) + RelVel_VecShift;
            Rel5_index_conversion = strfind(delta_norLength,FrShort_PETs(5,:)) + Rel5_maxRelVel_index - 1;
            Rel5_Rel20Vel_index = Rel20index(5) + RelVel_VecShift;
            Rel5_Rel80Vel_index = Rel80index(5) + RelVel_VecShift;
            Rel5_index_conversion20 = strfind(delta_norLength,FrShort_PETs(5,:)) + Rel5_Rel20Vel_index - 1;
            Rel5_index_conversion80 = strfind(delta_norLength,FrShort_PETs(5,:)) + Rel5_Rel80Vel_index - 1;
            Rel5_PreRegrPts = delta_norLength(Rel5_index_conversion - 1: Rel5_index_conversion + 1);
            %Rel1_index_conversion = strfind(delta_norLength,Rel1_PreRegrPts) + 2 ;
            Rel5_PregRegrTime = TotalTime(Rel5_index_conversion - 1: Rel5_index_conversion +1);
            Rel5_LinFit = fitlm(Rel5_PregRegrTime,Rel5_PreRegrPts);
            Rel5_LinCoeff = Rel5_LinFit.Coefficients.Estimate;
            Rel5_B = Rel5_LinCoeff(1,1);
            Rel5_m = Rel5_LinCoeff(2,1);
            Rel5_RelaxVel50 = Rel5_m;
            RelVel50 = [RelVel50, Rel5_RelaxVel50];
            Rel5_LinRegr = ((Rel5_m) * TotalTime) + Rel5_B;
            
            Rel5_PreRegrPts20 = delta_norLength(Rel5_index_conversion20 - 1: Rel5_index_conversion20 + 1);
            Rel5_PregRegrTime20 = TotalTime(Rel5_index_conversion20 - 1: Rel5_index_conversion20 +1);
            Rel5_LinFit20 = fitlm(Rel5_PregRegrTime20,Rel5_PreRegrPts20);
            Rel5_LinCoeff20 = Rel5_LinFit20.Coefficients.Estimate;
            Rel5_B20 = Rel5_LinCoeff20(1,1);
            Rel5_m20 = Rel5_LinCoeff20(2,1);
            Rel5_RelaxVel20 = Rel5_m20;
            RelVel20 = [RelVel20, Rel5_RelaxVel20];
            Rel5_LinRegr20 = ((Rel5_m20) * TotalTime) + Rel5_B20;
            Rel5_PreRegrPts80 = delta_norLength(Rel5_index_conversion80 - 1: Rel5_index_conversion80 + 1);
            Rel5_PregRegrTime80 = TotalTime(Rel5_index_conversion80 - 1: Rel5_index_conversion80 +1);
            Rel5_LinFit80 = fitlm(Rel5_PregRegrTime80,Rel5_PreRegrPts80);
            Rel5_LinCoeff80 = Rel5_LinFit80.Coefficients.Estimate;
            Rel5_B80 = Rel5_LinCoeff80(1,1);
            Rel5_m80 = Rel5_LinCoeff80(2,1);
            Rel5_RelaxVel80 = Rel5_m80;
            RelVel80 = [RelVel80, Rel5_RelaxVel80];
            Rel5_LinRegr80 = ((Rel5_m80) * TotalTime) + Rel5_B80;
            
            %if y= mt + b and y=0, t=-b/m
            Rel5_end = (-1 * Rel5_B)/ Rel5_m;
            Rel5_start = TotalTime(local_maxima(5));
            Rel5_time = Rel5_end - Rel5_start;
%           % Cont 1 Decel 10% deviation from max velocity
            for j = Rel5_index_conversion:-1:0
                avg_R5_a = mean(SpeedAll(j-2:j));
                avg_R5_b = mean(SpeedAll(Rel5_index_conversion-2:Rel5_index_conversion+2));
                ratio_R5 = avg_R5_a / avg_R5_b;
                if ratio_R5 <= 0.9 %10 percent deviation avg of max vel
                % check if successive avgerage is also 10 percent deviation
                    avg_R5_a = mean(SpeedAll(j-3:j-1));
                    avg_R5_b = mean(SpeedAll(Rel5_index_conversion-2:Rel5_index_conversion+2));
                    ratio_R5 = avg_R5_a / avg_R5_b;
                    if ratio_R5 <= 0.9
                        Rel5_Accel_end = j-1;
                        break
                    end
                end
            end
            Rel5_Accel_time = TotalTime(Rel5_Accel_end) - Rel5_start;
        else
            Rel5_time = NaN;
            Rel5_Accel_time = NaN;
        end
        
        
        %% Calculate Total Event Times
            Event1_time = Rel1_end - Cont1_start;
            %ensure no bugs for limited number of events
            if num_events > 1
                Event2_time = Rel2_end - Cont2_start;
            else
                Event2_time = NaN;
            end
            if num_events > 2
                Event3_time = Rel3_end - Cont3_start;
            else
                Event3_time = NaN;
            end
            if num_events > 3
                Event4_time = Rel4_end - Cont4_start;
            else
                Event4_time = NaN;
            end
            if num_events > 4
                Event5_time = Rel5_end - Cont5_start;
            else
                Event5_time = NaN;
            end
            
            
        %% QC Plot of Linear Regressions
        % Plot Linear regressions that were found for the time
        % calculations to check for quality control. The linear regressions
        % lines are expected to be an approximation for the displacement
        % curve near the baseline. To check for quality control, ensure the
        % linear regressions reach 0 (on y-axis) near where the
        % displacement curve approaches zero.
        figure,
        subplot(3,1,1); hold on;
        title('Linear Regression QC: 20% from Baseline');
        xlabel('Frame'); ylabel('% of peak');
        xsize = length(delta_norLength);
        plot(delta_norLength, 'k', 'LineWidth', 1);
        plot(Cont1_LinRegr20, '--r','LineWidth',1);
        plot(Rel1_LinRegr20, '--r','LineWidth',1);       
        if num_events > 1
        plot(Cont2_LinRegr20, '--c','LineWidth',1);
        plot(Rel2_LinRegr20, '--c','LineWidth',1);
        end
        if num_events > 2
        plot(Cont3_LinRegr20, '--g','LineWidth',1);
        plot(Rel3_LinRegr20, '--g','LineWidth',1);
        end
        if num_events > 3
        plot(Cont4_LinRegr20, '--b','LineWidth',1);
        plot(Rel4_LinRegr20, '--b','LineWidth',1);        
        end
        if num_events > 4
        plot(Cont5_LinRegr20, '--m','LineWidth',1);
        plot(Rel5_LinRegr20, '--m','LineWidth',1);
        end
        axis([0 xsize -1 10]);
        
        subplot(3,1,2); hold on;
        title('Linear Regression QC: 50% from Baseline');
        xsize = length(delta_norLength);
        plot(delta_norLength, 'k', 'LineWidth', 1);
        plot(Cont1_LinRegr, '--r','LineWidth',1);
        plot(Rel1_LinRegr, '--r','LineWidth',1);
        if num_events > 1
        plot(Cont2_LinRegr, '--c','LineWidth',1);
        plot(Rel2_LinRegr, '--c','LineWidth',1);
        end
        if num_events > 2
        plot(Cont3_LinRegr, '--g','LineWidth',1);
        plot(Rel3_LinRegr, '--g','LineWidth',1);
        end
        if num_events > 3
        plot(Cont4_LinRegr, '--b','LineWidth',1);
        plot(Rel4_LinRegr, '--b','LineWidth',1);        
        end
        if num_events > 4
        plot(Cont5_LinRegr, '--m','LineWidth',1);
        plot(Rel5_LinRegr, '--m','LineWidth',1);
        end
        xlabel('Frame'); ylabel('% of peak');
        axis([0 xsize -1 10]);
        
        subplot(3,1,3); hold on;
        title('Linear Regression QC: 80% from Baseline');
        xsize = length(delta_norLength);
        plot(delta_norLength, 'k', 'LineWidth', 1);
        plot(Cont1_LinRegr80, '--r','LineWidth',1);
        plot(Rel1_LinRegr80, '--r','LineWidth',1);
        if num_events > 1
        plot(Cont2_LinRegr80, '--c','LineWidth',1);
        plot(Rel2_LinRegr80, '--c','LineWidth',1);
        end
        if num_events > 2
        plot(Cont3_LinRegr80, '--g','LineWidth',1);
        plot(Rel3_LinRegr80, '--g','LineWidth',1);
        end
        if num_events > 3
        plot(Cont4_LinRegr80, '--b','LineWidth',1);
        plot(Rel4_LinRegr80, '--b','LineWidth',1);        
        end
        if num_events > 4
        plot(Cont5_LinRegr80, '--m','LineWidth',1);
        plot(Rel5_LinRegr80, '--m','LineWidth',1);
        end
        xlabel('Frame'); ylabel('% of peak');
        axis([0 xsize -1 10]);
        
        filename = sprintf('%s_Linear_Regressions',name);
        filename = sprintf('%s.fig',filename);
        cd(dirOut)
        savefig(filename);
        cd(Path)
        fprintf('Linear Regression QC Plots saved as %s\n', filename)
       
        hold off;
       
    
        
        %% Calculate mean/median/std
        % Calculate mean, median, and standard deviations for all time
        % measurements (See annotations for "if num_events == 1")
        if num_events == 1
            % Total Event Time mean, median, and mode calculations
            median_event_time = median([Event1_time]);
            mean_event_time = mean([Event1_time]);
            std_event_time = std([Event1_time]);
            % Contraction Time mean, median, and mode calculations
            median_Contraction_time = median([Cont1_time]);
            mean_Contraction_time = mean([Cont1_time]);
            std_Contraction_time = std([Cont1_time]);
            % Contraction Deceleration Time mean, median, and mode calculations
            median_Contraction_Deceleration_time = median([Cont1_Decel_time]);
            mean_Contraction_Deceleration_time = mean([Cont1_Decel_time]);
            std_Contraction_Deceleration_time = std([Cont1_Decel_time]);
            % Relaxation Time mean, median, and mode calculations
            median_Relaxation_time = median([Rel1_time]);
            mean_Relaxation_time = mean([Rel1_time]);
            std_Relaxation_time = std([Rel1_time]);
            % Relaxation Acceleration Time mean, median, and mode calculations
            median_Relaxation_Acceleration_time = median([Rel1_Accel_time]);
            mean_Relaxation_Acceleration_time = mean([Rel1_Accel_time]);
            std_Relaxation_Acceleration_time = std([Rel1_Accel_time]);
        end
        if num_events == 2
            median_event_time = median([Event1_time,Event2_time]);
            mean_event_time = mean([Event1_time,Event2_time]);
            std_event_time = std([Event1_time,Event2_time]);
            median_Contraction_time = median([Cont1_time,Cont2_time]);
            mean_Contraction_time = mean([Cont1_time,Cont2_time]);
            std_Contraction_time = std([Cont1_time,Cont2_time]);
            median_Contraction_Deceleration_time = median([Cont1_Decel_time,Cont2_Decel_time]);
            mean_Contraction_Deceleration_time = mean([Cont1_Decel_time,Cont2_Decel_time]);
            std_Contraction_Deceleration_time = std([Cont1_Decel_time,Cont2_Decel_time]);
            median_Relaxation_time = median([Rel1_time,Rel2_time]);
            mean_Relaxation_time = mean([Rel1_time,Rel2_time]);
            std_Relaxation_time = std([Rel1_time,Rel2_time]);
            median_Relaxation_Acceleration_time = median([Rel1_Accel_time,Rel2_Accel_time]);
            mean_Relaxation_Acceleration_time = mean([Rel1_Accel_time,Rel2_Accel_time]);
            std_Relaxation_Acceleration_time = std([Rel1_Accel_time,Rel2_Accel_time]); 
        end
        if num_events == 3
            median_event_time = median([Event1_time,Event2_time,Event3_time]);
            mean_event_time = mean([Event1_time,Event2_time,Event3_time]);
            std_event_time = std([Event1_time,Event2_time,Event3_time]);
            median_Contraction_time = median([Cont1_time,Cont2_time,Cont3_time]);
            mean_Contraction_time = mean([Cont1_time,Cont2_time,Cont3_time]);
            std_Contraction_time = std([Cont1_time,Cont2_time,Cont3_time]);
            median_Contraction_Deceleration_time = median([Cont1_Decel_time,Cont2_Decel_time,Cont3_Decel_time]);
            mean_Contraction_Deceleration_time = mean([Cont1_Decel_time,Cont2_Decel_time,Cont3_Decel_time]);
            std_Contraction_Deceleration_time = std([Cont1_Decel_time,Cont2_Decel_time,Cont3_Decel_time]);
            median_Relaxation_time = median([Rel1_time,Rel2_time,Rel3_time]);
            mean_Relaxation_time = mean([Rel1_time,Rel2_time,Rel3_time]);
            std_Relaxation_time = std([Rel1_time,Rel2_time,Rel3_time]);
            median_Relaxation_Acceleration_time = median([Rel1_Accel_time,Rel2_Accel_time,Rel3_Accel_time]);
            mean_Relaxation_Acceleration_time = mean([Rel1_Accel_time,Rel2_Accel_time,Rel3_Accel_time]);
            std_Relaxation_Acceleration_time = std([Rel1_Accel_time,Rel2_Accel_time,Rel3_Accel_time]); 
        end
        if num_events == 4
            median_event_time = median([Event1_time,Event2_time,Event3_time,Event4_time]);
            mean_event_time = mean([Event1_time,Event2_time,Event3_time,Event4_time]);
            std_event_time = std([Event1_time,Event2_time,Event3_time,Event4_time]);
            median_Contraction_time = median([Cont1_time,Cont2_time,Cont3_time,Cont4_time]);
            mean_Contraction_time = mean([Cont1_time,Cont2_time,Cont3_time,Cont4_time]);
            std_Contraction_time = std([Cont1_time,Cont2_time,Cont3_time,Cont4_time]);
            median_Contraction_Deceleration_time = median([Cont1_Decel_time,Cont2_Decel_time,Cont3_Decel_time,Cont4_Decel_time]);
            mean_Contraction_Deceleration_time = mean([Cont1_Decel_time,Cont2_Decel_time,Cont3_Decel_time,Cont4_Decel_time]);
            std_Contraction_Deceleration_time = std([Cont1_Decel_time,Cont2_Decel_time,Cont3_Decel_time,Cont4_Decel_time]);
            median_Relaxation_time = median([Rel1_time,Rel2_time,Rel3_time,Rel4_time]);
            mean_Relaxation_time = mean([Rel1_time,Rel2_time,Rel3_time,Rel4_time]);
            std_Relaxation_time = std([Rel1_time,Rel2_time,Rel3_time,Rel4_time]);
            median_Relaxation_Acceleration_time = median([Rel1_Accel_time,Rel2_Accel_time,Rel3_Accel_time,Rel4_Accel_time]);
            mean_Relaxation_Acceleration_time = mean([Rel1_Accel_time,Rel2_Accel_time,Rel3_Accel_time,Rel4_Accel_time]);
            std_Relaxation_Acceleration_time = std([Rel1_Accel_time,Rel2_Accel_time,Rel3_Accel_time,Rel4_Accel_time]); 
        end
        if num_events >= 5
            median_event_time = median([Event1_time,Event2_time,Event3_time,Event4_time,Event5_time]);
            mean_event_time = mean([Event1_time,Event2_time,Event3_time,Event4_time,Event5_time]);
            std_event_time = std([Event1_time,Event2_time,Event3_time,Event4_time,Event5_time]);
            median_Contraction_time = median([Cont1_time,Cont2_time,Cont3_time,Cont4_time,Cont5_time]);
            mean_Contraction_time = mean([Cont1_time,Cont2_time,Cont3_time,Cont4_time,Cont5_time]);
            std_Contraction_time = std([Cont1_time,Cont2_time,Cont3_time,Cont4_time,Cont5_time]);
            median_Contraction_Deceleration_time = median([Cont1_Decel_time,Cont2_Decel_time,Cont3_Decel_time,Cont4_Decel_time,Cont5_Decel_time]);
            mean_Contraction_Deceleration_time = mean([Cont1_Decel_time,Cont2_Decel_time,Cont3_Decel_time,Cont4_Decel_time,Cont5_Decel_time]);
            std_Contraction_Deceleration_time = std([Cont1_Decel_time,Cont2_Decel_time,Cont3_Decel_time,Cont4_Decel_time,Cont5_Decel_time]);
            median_Relaxation_time = median([Rel1_time,Rel2_time,Rel3_time,Rel4_time,Rel5_time]);
            mean_Relaxation_time = mean([Rel1_time,Rel2_time,Rel3_time,Rel4_time,Rel5_time]);
            std_Relaxation_time = std([Rel1_time,Rel2_time,Rel3_time,Rel4_time,Rel5_time]);
            median_Relaxation_Acceleration_time = median([Rel1_Accel_time,Rel2_Accel_time,Rel3_Accel_time,Rel4_Accel_time,Rel5_Accel_time]);
            mean_Relaxation_Acceleration_time = mean([Rel1_Accel_time,Rel2_Accel_time,Rel3_Accel_time,Rel4_Accel_time,Rel5_Accel_time]);
            std_Relaxation_Acceleration_time = std([Rel1_Accel_time,Rel2_Accel_time,Rel3_Accel_time,Rel4_Accel_time,Rel5_Accel_time]);
        end

%Contraction Statistics        
        
        TrackingDistance_um = maxLength * PixelDistance;

        median_Contract_50Vel = median(ContractVel50);
        median_Contract_20Vel = median(ContractVel20);
        median_Contract_80Vel = median(ContractVel80);
        median_max_ContractAccel = median(max(ContractAccel_PETs, [], 2));
        median_Relax_50Vel = median(RelVel50);
        median_Relax_20Vel = median(RelVel20);
        median_Relax_80Vel = median(RelVel80);
        
        std_Contract_50Vel = std(ContractVel50);
        std_Contract_20Vel = std(ContractVel20);
        std_Contract_80Vel = std(ContractVel80);
        std_max_ContractAccel = std(max(ContractAccel_PETs, [], 2));
        std_Relax_50Vel = std(RelVel50);
        std_Relax_20Vel = std(RelVel20);
        std_Relax_80Vel = std(RelVel80);
        
        median_Contract_20VelNorm = median_Contract_20Vel / median_max_FrShort;
        median_Contract_50VelNorm = median_Contract_50Vel / median_max_FrShort;
        median_Contract_80VelNorm = median_Contract_80Vel / median_max_FrShort;
        median_Relax_80VelNorm = median_Relax_80Vel / median_max_FrShort;
        median_Relax_50VelNorm = median_Relax_50Vel / median_max_FrShort;
        median_Relax_20VelNorm = median_Relax_20Vel / median_max_FrShort;
           
        %% Save data to .xlsx 
        filename = sprintf('%s_Results.xlsx',name);
        % Create Empty 19 row X 12 column Matrix to fill
        % To intepret data from Excel sheet, the refer to the variable
        % assignments below to matrix A(row,column)
        A = zeros(12, 36,'double');
        A(1,1) = onsets(1);
        if num_events>1
            A(1,2) = onsets(2);
               if num_events>2
                   A(1,3)=onsets(3);
                   if num_events>3
                       A(1,4)=onsets(4);
                       if num_events>4
                           A(1,5)=onsets(5);
                       end
                   end
               end
        end
        A(1,6) = local_maxima(1);
        if num_events>1
            A(1,7) = local_maxima(2);
               if num_events>2
                   A(1,8)=local_maxima(3);
                   if num_events>3
                       A(1,9)=local_maxima(4);
                       if num_events>4
                           A(1,10)=local_maxima(5);
                       end
                   end
               end
        end
        A(1,11) = local_maxima(1)-onsets(1);
        if num_events>1
            A(1,12) = local_maxima(2)-onsets(2);
               if num_events>2
                   A(1,13)=local_maxima(3)-onsets(3);
                   if num_events>3
                       A(1,14)=local_maxima(4)-onsets(4);
                       if num_events>4
                           A(1,15)=local_maxima(5)-onsets(5);
                       end
                   end
               end
        end
        
    
        A(2,1) = TrackingDistance_um;
        A(2,2) = PixelDistance;
        A(2,3) = ContractionFrequency;
        A(2,4) = median_max_FrShort;
        A(2,5) = median_min_Length;
        A(2,6) = median_Contract_20Vel;
        A(2,7) = median_Contract_50Vel;
        A(2,8) = median_Contract_80Vel;
        A(2,9) = median_Relax_80Vel;
        A(2,10) = median_Relax_50Vel;
        A(2,11) = median_Relax_20Vel;
        A(2,12) = median_Contract_20VelNorm;
        A(2,13) = median_Contract_50VelNorm;
        A(2,14) = median_Contract_80VelNorm;
        A(2,15) = median_Relax_80VelNorm;
        A(2,16) = median_Relax_50VelNorm;
        A(2,17) = median_Relax_20VelNorm;
        A(2,18) = median_max_ContractAccel;
        A(2,19) = median_Relaxation_Acceleration_time;        
        A(2,20) = median_Contraction_time;
        A(2,21) = median_Contraction_Deceleration_time;
        A(2,22) = median_Relaxation_time;
        A(2,23) = median_event_time;       
        A(2,24) = median_max_Contract_Vel;
        A(2,25) = median_max_Relax_Vel;
        A(2,26) = Velocity_Asymmetry_Index;
        A(2,27) = std_inst_fre;        
        A(2,28) = std_max_FrShort;
        A(2,29) = std_min_Length;
        A(2,30) = std_Contract_20Vel;
        A(2,31) = std_Contract_50Vel;
        A(2,32) = std_Contract_80Vel;
        A(2,33) = std_Relax_80Vel;
        A(2,34) = std_Relax_50Vel;
        A(2,35) = std_Relax_20Vel;
        A(2,36) = std_max_ContractAccel;
        A(2,37) = std_Relaxation_Acceleration_time;
        A(2,38) = std_Contraction_time;
        A(2,39) = std_Contraction_Deceleration_time;
        A(2,40) = std_Relaxation_time;
        A(2,41) = std_event_time;
        A(2,42) = std_max_Contract_Vel;        
        A(2,43) = std_max_Relax_Vel;
        A(3,1) = Cont1_FrShort;
        A(3,2) = Cont2_FrShort;
        A(3,3) = Cont3_FrShort;
        A(3,4) = Cont4_FrShort;
        A(3,5) = Cont5_FrShort;
        A(4,1) = Cont1_ContractVel50;
        A(4,2) = Cont2_ContractVel50;
        A(4,3) = Cont3_ContractVel50;
        A(4,4) = Cont4_ContractVel50;
        A(4,5) = Cont5_ContractVel50;
        A(5,1) = Cont1_RelaxVel50;
        A(5,2) = Cont2_RelaxVel50;
        A(5,3) = Cont3_RelaxVel50;
        A(5,4) = Cont4_RelaxVel50;
        A(5,5) = Cont5_RelaxVel50;
        A(6,1) = Cont1_ContractAccel;
        A(6,2) = Cont2_ContractAccel;
        A(6,3) = Cont3_ContractAccel;
        A(6,4) = Cont4_ContractAccel;
        A(6,5) = Cont5_ContractAccel;
        A(7,1:length(inst_fre)) = inst_fre;
        A(8,1) = Event1_time;
        A(8,2) = Event2_time;
        A(8,3) = Event3_time;
        A(8,4) = Event4_time;
        A(8,5) = Event5_time;
        A(9,1) = Cont1_time;
        A(9,2) = Cont2_time;
        A(9,3) = Cont3_time;
        A(9,4) = Cont4_time;
        A(9,5) = Cont5_time;
        A(10,1) = Cont1_Decel_time;
        A(10,2) = Cont2_Decel_time;
        A(10,3) = Cont3_Decel_time;
        A(10,4) = Cont4_Decel_time;
        A(10,5) = Cont5_Decel_time;
        A(11,1) = Rel1_time;
        A(11,2) = Rel2_time;
        A(11,3) = Rel3_time;
        A(11,4) = Rel4_time;
        A(11,5) = Rel5_time;
        A(12,1) = Rel1_Accel_time;
        A(12,2) = Rel2_Accel_time;
        A(12,3) = Rel3_Accel_time;
        A(12,4) = Rel4_Accel_time;
        A(12,5) = Rel5_Accel_time;
        A(isnan(A)) = 0;
        
        Results = A;
        cd(dirOut)
        xlswrite(filename,A)
        cd(Path)
        
        toc            

        % End of Edits
        %%
        
        figure,
        subplot(5,1,1);hold on;
        title('Whole Video Normalized Plot');
        xlabel('Frame'); ylabel('% of peak');
        plot(movmean(nor_delta_norLength,3),'color','k','LineWidth',1);
        plot(movmean(norSpeedAll,3),'color','r','LineWidth',1);        
        %plot(movmean(norAccelarationAll,3),'color','b','LineWidth',1);
        %plot(movmean(nor_asymmetricIndex,3),'color','g','LineWidth',1);
        set(gcf, 'position', [450 100 500 800]);
        
        subplot(5,1,2);
        title('Displacement');
        shadedErrorBar(1:length(FrShort_PETs),mean_FrShort_PETs,sem_FrShort_PETs,'lineProps','-k');
        xlabel('Frame'); ylabel('(% of total length)');
        
        subplot(5,1,3);
        title('Speed');
        shadedErrorBar(1:length(FrShort_PETs),mean_Speed_PETs,sem_Speed_PETs,'lineProps','-r');
        xlabel('Frame'); ylabel('(um/s)');
        
        subplot(5,1,4);
        title('Accelaration');
        shadedErrorBar(1:length(FrShort_PETs),mean_Accel_PETs,sem_Accel_PETs,'lineProps','-b');
        xlabel('Frame'); ylabel('(um/s^2)');
        
        subplot(5,1,5);
        title('Speed Asymmetric Index ');
        shadedErrorBar(1:length(FrShort_PETs),mean_Symme_PETs,sem_Symme_PETs,'lineProps','-g');
        xlabel('Frame'); ylabel('(left-right)/(left+right+1)');

        % Save PET traces
        filename = sprintf('%s_PETs',name);%Prompt user
        fprintf('PETs saved as %s\n', filename)
        hfigs = get(0, 'children');
        figure(size(hfigs(:),1));
        cd(dirOut)
        saveas(size(hfigs(:),1), [filename '.fig']);
        cd(Path)
        
end

function varargout=shadedErrorBar(x,y,errBar,varargin)
% generate continuous error bar area around a line plot
%
% function H=shadedErrorBar(x,y,errBar, ...)
%
% Purpose 
% Makes a 2-d line plot with a pretty shaded error bar made
% using patch. Error bar color is chosen automatically.
%
%
% Inputs (required)
% x - vector of x values [optional, can be left empty]
% y - vector of y values or a matrix of n observations by m cases
%     where m has length(x);
% errBar - if a vector we draw symmetric errorbars. If it has a size
%          of [2,length(x)] then we draw asymmetric error bars with
%          row 1 being the upper bar and row 2 being the lower bar
%          (with respect to y -- see demo). ** alternatively ** 
%          errBar can be a cellArray of two function handles. The 
%          first defines statistic the line should be and the second 
%          defines the error bar.
%
% Inputs (optional, param/value pairs)
% 'lineProps' - ['-k' by default] defines the properties of
%             the data line. e.g.:    
%             'or-', or {'-or','markerfacecolor',[1,0.2,0.2]}
% 'transparent' - [true  by default] if true, the shaded error
%               bar is made transparent. However, for a transparent
%               vector image you will need to save as PDF, not EPS,
%               and set the figure renderer to "painters". An EPS 
%               will only be transparent if you set the renderer 
%               to OpenGL, however this makes a raster image.
% 'patchSaturation'- [0.2 by default] The saturation of the patch color.
%
%
%
% Outputs
% H - a structure of handles to the generated plot objects.
%
%
% Examples:
% y=randn(30,80); 
% x=1:size(y,2);
%
% 1)
% shadedErrorBar(x,mean(y,1),std(y),'lineprops','g');
%
% 2)
% shadedErrorBar(x,y,{@median,@std},'lineprops',{'r-o','markerfacecolor','r'});
%
% 3)
% shadedErrorBar([],y,{@median,@(x) std(x)*1.96},'lineprops',{'r-o','markerfacecolor','k'});
%
% 4)
% Overlay two transparent lines:
% clf
% y=randn(30,80)*10; 
% x=(1:size(y,2))-40;
% shadedErrorBar(x,y,{@mean,@std},'lineprops','-r','transparent',1);
% hold on
% y=ones(30,1)*x; y=y+0.06*y.^2+randn(size(y))*10;
% shadedErrorBar(x,y,{@mean,@std},'lineprops','-b','transparent',1);
% hold off
%
%
% Rob Campbell - November 2009



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parse input arguments
narginchk(3,inf)

params = inputParser;
params.CaseSensitive = false;
params.addParameter('lineProps', '-k', @(x) ischar(x) | iscell(x));
params.addParameter('transparent', true, @(x) islogical(x) || x==0 || x==1);
params.addParameter('patchSaturation', 0.2, @(x) isnumeric(x) && x>=0 && x<=1);

params.parse(varargin{:});

%Extract values from the inputParser
lineProps =  params.Results.lineProps;
transparent =  params.Results.transparent;
patchSaturation = params.Results.patchSaturation;

if ~iscell(lineProps), lineProps={lineProps}; end


%Process y using function handles if needed to make the error bar dynamically
if iscell(errBar) 
    fun1=errBar{1};
    fun2=errBar{2};
    errBar=fun2(y);
    y=fun1(y);
else
    y=y(:).';
end

if isempty(x)
    x=1:length(y);
else
    x=x(:).';
end


%Make upper and lower error bars if only one was specified
if length(errBar)==length(errBar(:))
    errBar=repmat(errBar(:)',2,1);
else
    s=size(errBar);
    f=find(s==2);
    if isempty(f), error('errBar has the wrong size'), end
    if f==2, errBar=errBar'; end
end

if length(x) ~= length(errBar)
    error('length(x) must equal length(errBar)')
end


%Log the hold status so we don't change
initialHoldStatus=ishold;
if ~initialHoldStatus, hold on,  end

H = makePlot(x,y,errBar,lineProps,transparent,patchSaturation);

if ~initialHoldStatus, hold off, end

if nargout==1
    varargout{1}=H;
end



function H = makePlot(x,y,errBar,lineProps,transparent,patchSaturation)

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Plot to get the parameters of the line

    H.mainLine=plot(x,y,lineProps{:});


    % Work out the color of the shaded region and associated lines.
    % Here we have the option of choosing alpha or a de-saturated
    % solid colour for the patch surface.
    mainLineColor=get(H.mainLine,'color');
    edgeColor=mainLineColor+(1-mainLineColor)*0.55;

    if transparent
        faceAlpha=patchSaturation;
        patchColor=mainLineColor;
    else
        faceAlpha=1;
        patchColor=mainLineColor+(1-mainLineColor)*(1-patchSaturation);
    end


    %Calculate the error bars
    uE=y+errBar(1,:);
    lE=y-errBar(2,:);


    %Add the patch error bar



    %Make the patch
    yP=[lE,fliplr(uE)];
    xP=[x,fliplr(x)];

    %remove nans otherwise patch won't work
    xP(isnan(yP))=[];
    yP(isnan(yP))=[];


    if(isdatetime(x))
        H.patch=patch(datenum(xP),yP,1);
    else
        H.patch=patch(xP,yP,1);
    end

    set(H.patch,'facecolor',patchColor, ...
        'edgecolor','none', ...
        'facealpha',faceAlpha)


    %Make pretty edges around the patch. 
    H.edge(1)=plot(x,lE,'-','color',edgeColor);
    H.edge(2)=plot(x,uE,'-','color',edgeColor);



    uistack(H.mainLine,'top') % Bring the main line to the top
end
end

function twimshow1(z, cmap, datasetNames, curImInd)
% modified by Yu-Wei with plotTrace function
%
    link_cmaps = false;
    
    if ~iscell(z), z={z}; end
    
    if ~exist('cmap','var') || isempty(cmap)
         cmap{1}= [];
    elseif ~iscell(cmap)
        cmap= {cmap};
    end
    
    if (numel(cmap)==1), link_cmaps = true; end
    
    for m=1:numel(cmap)
        if isempty(cmap{m})
            cmap{m} = [min(z{m}(:)) max(z{m}(:))];
        end
    end
    
    if ~exist('datasetNames','var'), datasetNames=[]; end;
    % fill in missing names with dataset indecies
    for k=(numel(datasetNames)+1):numel(z); 
        datasetNames{k} = num2str(k);
    end
        
    if ~exist('curImInd','var'), curImInd = 1; end
    prevImInd = 1;
    hImage = [];
    hTitle = [];
    curFrameInd =1;
    SetCurrentImage(curImInd);

    set(gcf, 'WindowKeyPressFcn',@KeyPress_proc);
    
    function KeyPress_proc(~,evnt)
        switch evnt.Key 
            case{'t'}
                SetCurrentImage(curImInd+1);
            case{'rightarrow'}
                SetCurrentFrame(curFrameInd+1);
            case{'leftarrow'}
                SetCurrentFrame(curFrameInd-1);
            case{'c'}
                imcontrast
            case{'r'}
                impixelregion
            case{'o'} % plot original traces(singal pixel) from multiple movie
                plotTrace(z,0,1)            
            case{'a'} % plot 11*11 'average' traces from multiple movie
                plotTrace(z,1,1)
            case{'g'} % plot 7*7 'gaussian' traces from multiple movie
                plotTrace(z,2,1)
            case{'m'} % plot 5*5 'average' traces from multiple points of the first movie
                plotTrace(z,1,0)
            case{'1','2','3','4','5','6','7','8','9','0'}
                ind=str2double(evnt.Character);
                if ind==0, ind=10; end
                if ind <= numel(z), SetCurrentImage(ind); end
        end
    end
    function SetCurrentImage(imIndex)
        if imIndex > numel(z), imIndex =1; end
        
        prevImInd = curImInd;    
        curImInd = imIndex;
        
        if ~link_cmaps && ~isempty(hImage)
            cmap{prevImInd} = get(gca,'CLim');
            set(gca,'CLim',cmap{curImInd});  
        end
        
        displayimage
    end
    function SetCurrentFrame(frameInd)
        if frameInd > size(z{curImInd},3) 
            frameInd = 1; 
        elseif frameInd < 1
            frameInd = size(z{curImInd},3); 
        end
        curFrameInd = frameInd;
        displayimage
    end
    function displayimage
        titleString = sprintf('%s Frame:%d', datasetNames{curImInd},curFrameInd);
        if isempty(hImage)
            figure;
            hImage = imshow(z{curImInd}(:,:,curFrameInd), cmap{curImInd});
            hTitle = title(gca, titleString);
            return;
        end
        
        set(hImage, 'CData',z{curImInd}(:,:,curFrameInd));
        set(hTitle,'String', titleString);
    end 

    function plotTrace(z,filter, mode)
    numFrames = size(z{1},3);
    [xx yy]=ginput;
%     ROI = sprintf('ROI %d', size(ginput,1));
%     gtext(ROI,'Color',[1 1 1]);
    color = {'k','r','b','g','y','c','m','k','r','b','g','y','c','m'};
    m = numel(z);
    figure;
    hold on
    for n = 1: numel(xx)
      x = uint16(xx(n));
      y = uint16(yy(n));
       switch filter
          case 0
              switch mode
                  case 0
                    str = sprintf('original x,y = %d,%d', x,y);
                    plot(1:numFrames,squeeze(z{k}(y,x,:)),color{n});
                  case 1
                    str = sprintf('original x,y = %d,%d', x,y);
                    for k = 1: m                
                    plot(1:numFrames,squeeze(z{k}(y,x,:)),color{k});
                    end
              end
          case 1
              H = fspecial('average',7);            
              switch mode
                  case 0
                      str = sprintf('5*5 AVG x,y = %d,%d', x,y);
                      z1{1} = z{1}(y-3:y+3 , x-3:x+3, :);
                      z2{1} = imfilter(z1{1},H);             
                      plot(1:numFrames,squeeze(z2{1}(3,3,:)),color{n});
                  case 1
                      str = sprintf('5*5 AVG x,y = %d,%d', x,y);
                      for k = 1: m
                      z1{k} = z{k}(y-3:y+3 , x-3:x+3, :);
                      z2{k} = imfilter(z1{k},H);             
                      plot(1:numFrames,squeeze(z2{k}(5,5,:)),color{k});
                      end
              end
          case 2
              H = fspecial('gaussian',7,1);
              switch mode
                  case 0
                      str = sprintf('7*7 gaussian x,y = %d,%d', x,y);
                      z1{1} = z{1}(y-3:y+3 , x-3:x+3, :);
                      z2{1} = imfilter(z1{1},H);             
                      plot(1:numFrames,squeeze(z2{1}(3,3,:)),color{n});
                  case 1
                      str = sprintf('7*7 gaussian x,y = %d,%d', x,y);
                      for k = 1: m
                        z1{k} = z{k}(y-3:y+3 , x-3:x+3, :);
                        z2{k} = imfilter(z1{k},H);             
                        plot(1:numFrames,squeeze(z2{k}(3,3,:)),color{k});
                      end      
              end
       end
    end
    hold off
    title(str)
    end
end

function [z,Location_X,Location_Y] = CorrectOffset_YT(z,maxPossibleOffset)
% Frame offset correction
% maxPossibleOffset=20; %you expect at most 10 pixel offset
%chnkWidth is the check frame interval. ex: every frame: chnkWidth = 1.
chnkWidth = 1; 
st=1; %starting frame

% get a refernce from averaged 10 frames 
% refMean = mean(z(:,:,st:(st+(10-1))),3);
refMean = mean(z(:,:,st:st+3),3);
st=st;%+chnkWidth;

while st<=size(z,3)
    testMean = mean( z(maxPossibleOffset:(end-maxPossibleOffset+1), maxPossibleOffset:(end-maxPossibleOffset+1), st:(st+(chnkWidth-1))), 3);
    cc = normxcorr2(testMean, refMean); %check the crosscorrelation between the test frame and the reference frame 
    
    [max_cc, imax] = max(abs(cc(:)));
    [ypeak, xpeak] = ind2sub(size(cc),imax(1)); % get the x-y index of best correllation.
    Location_X(st)= xpeak;
    Location_Y(st)= ypeak;
    corr_offset = [ (ypeak-size(testMean,1)) (xpeak-size(testMean,2)) ]-maxPossibleOffset+1;
    for fr=st:(st+(chnkWidth-1))
        z(:, :, fr) = circshift(z(:, :, fr),corr_offset);
    end

    st=st+chnkWidth;
    if (st+2*chnkWidth-1)>size(z,3)
        chnkWidth = size(z,3)-st+1;
    end
end
end